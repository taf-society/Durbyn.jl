<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Grammar · Durbyn.jl</title><meta name="title" content="Grammar · Durbyn.jl"/><meta property="og:title" content="Grammar · Durbyn.jl"/><meta property="twitter:title" content="Grammar · Durbyn.jl"/><meta name="description" content="Documentation for Durbyn.jl."/><meta property="og:description" content="Documentation for Durbyn.jl."/><meta property="twitter:description" content="Documentation for Durbyn.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/theme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Durbyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Durbyn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><span class="tocitem">User Guide</span><ul><li class="is-active"><a class="tocitem" href>Grammar</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#ARIMA-Grammar"><span>ARIMA Grammar</span></a></li><li><a class="tocitem" href="#ETS-Grammar"><span>ETS Grammar</span></a></li><li><a class="tocitem" href="#Multi-Model-Fitting"><span>Multi-Model Fitting</span></a></li><li><a class="tocitem" href="#Complete-End-to-End-Example"><span>Complete End-to-End Example</span></a></li><li><a class="tocitem" href="#ARAR-Grammar"><span>ARAR Grammar</span></a></li><li><a class="tocitem" href="#ARARMA-Grammar"><span>ARARMA Grammar</span></a></li><li><a class="tocitem" href="#Tips-and-Best-Practices"><span>Tips and Best Practices</span></a></li></ul></li><li><a class="tocitem" href="../expsmoothing/">Exponential Smoothing</a></li><li><a class="tocitem" href="../intermittent/">Intermittent Demand</a></li><li><a class="tocitem" href="../arima/">ARIMA</a></li><li><a class="tocitem" href="../ararma/">ARAR/ARARMA</a></li><li><a class="tocitem" href="../tableops/">Table Operations</a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Grammar</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Grammar</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/taf-society/Durbyn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/taf-society/Durbyn.jl/blob/main/docs/src/grammar.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Durbyn-Grammar"><a class="docs-heading-anchor" href="#Durbyn-Grammar">Durbyn Grammar</a><a id="Durbyn-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Durbyn-Grammar" title="Permalink"></a></h1><p>Durbyn provides an expressive, composable grammar for defining forecasting models. This unified interface lets you describe ARIMA, SARIMA, and exponential smoothing models with concise, readable syntax using the <code>@formula</code> macro and specialized model specifications.</p><p>Future releases will extend this grammar to support additional statistical models (state space models, structural time series, etc.) and machine learning forecasting methods, all accessible through the same consistent interface.</p><hr/><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The Durbyn grammar system consists of:</p><ul><li><strong>Formula interface</strong>: Use <code>@formula</code> to declaratively specify model components</li><li><strong>Model specifications</strong>: Wrap formulas in specs like <code>ArimaSpec</code>, <code>EtsSpec</code>, <code>SesSpec</code>, etc.</li><li><strong>Unified fitting</strong>: Call <code>fit(spec, data)</code> with optional grouping for panel data</li><li><strong>Consistent forecasting</strong>: Use <code>forecast(fitted, h)</code> for both single and grouped models; external variables can be passed if the model supports them</li></ul><p>This design eliminates manual tuning loops and provides a consistent interface across all model families.</p><hr/><h2 id="ARIMA-Grammar"><a class="docs-heading-anchor" href="#ARIMA-Grammar">ARIMA Grammar</a><a id="ARIMA-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMA-Grammar" title="Permalink"></a></h2><p>The ARIMA grammar lets you describe ARIMA and SARIMA models with flexible order specifications and exogenous variable support.</p><h3 id="Formula-Basics"><a class="docs-heading-anchor" href="#Formula-Basics">Formula Basics</a><a id="Formula-Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Formula-Basics" title="Permalink"></a></h3><p>Define the relationship between a response variable (target in ML terminology) and its ARIMA structure:</p><pre><code class="language-julia hljs">@formula(sales = p() + d() + q())</code></pre><p>Every formula requires a <strong>response variable</strong> (left-hand side; called <em>target</em> in ML) and one or more model components (right-hand side). Components may specify ARIMA orders, seasonal orders, or <strong>regressors</strong> (exogenous variables; called <em>features</em> in ML).</p><h3 id="Non-Seasonal-Orders"><a class="docs-heading-anchor" href="#Non-Seasonal-Orders">Non-Seasonal Orders</a><a id="Non-Seasonal-Orders-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Seasonal-Orders" title="Permalink"></a></h3><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Meaning</th><th style="text-align: right">Default or form</th></tr><tr><td style="text-align: right"><code>p()</code></td><td style="text-align: right">Non-seasonal AR order</td><td style="text-align: right">Search range 2–5</td></tr><tr><td style="text-align: right"><code>p(k)</code></td><td style="text-align: right">Fix AR order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>p(min,max)</code></td><td style="text-align: right">Search AR order range</td><td style="text-align: right">Searches <code>min</code> through <code>max</code></td></tr><tr><td style="text-align: right"><code>d()</code></td><td style="text-align: right">Differencing order (auto)</td><td style="text-align: right"><code>auto_arima</code> chooses</td></tr><tr><td style="text-align: right"><code>d(k)</code></td><td style="text-align: right">Fix differencing order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>q()</code></td><td style="text-align: right">Non-seasonal MA order</td><td style="text-align: right">Search range 2–5</td></tr><tr><td style="text-align: right"><code>q(k)</code></td><td style="text-align: right">Fix MA order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>q(min,max)</code></td><td style="text-align: right">Search MA order range</td><td style="text-align: right">Searches <code>min</code> through <code>max</code></td></tr></table><p>Any range <code>(min,max)</code> triggers full <code>auto_arima</code> search. If all orders are fixed, the formula interface automatically calls the faster <code>arima</code> routine.</p><h3 id="Seasonal-Orders"><a class="docs-heading-anchor" href="#Seasonal-Orders">Seasonal Orders</a><a id="Seasonal-Orders-1"></a><a class="docs-heading-anchor-permalink" href="#Seasonal-Orders" title="Permalink"></a></h3><p>Seasonal counterparts include <code>P</code>, <code>D</code>, and <code>Q</code>:</p><pre><code class="language-julia hljs">@formula(sales = p() + d() + q() + P() + Q())</code></pre><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Meaning</th><th style="text-align: right">Default or form</th></tr><tr><td style="text-align: right"><code>P()</code></td><td style="text-align: right">Seasonal AR order</td><td style="text-align: right">Search range 1–2</td></tr><tr><td style="text-align: right"><code>P(k)</code></td><td style="text-align: right">Fix seasonal AR order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>P(min,max)</code></td><td style="text-align: right">Search seasonal AR order range</td><td style="text-align: right">Searches <code>min</code> through <code>max</code></td></tr><tr><td style="text-align: right"><code>D()</code></td><td style="text-align: right">Seasonal differencing (auto)</td><td style="text-align: right"><code>auto_arima</code> chooses</td></tr><tr><td style="text-align: right"><code>D(k)</code></td><td style="text-align: right">Fix seasonal differencing order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>Q()</code></td><td style="text-align: right">Seasonal MA order</td><td style="text-align: right">Search range 1–2</td></tr><tr><td style="text-align: right"><code>Q(k)</code></td><td style="text-align: right">Fix seasonal MA order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>Q(min,max)</code></td><td style="text-align: right">Search seasonal MA order range</td><td style="text-align: right">Searches <code>min</code> through <code>max</code></td></tr></table><p>Remember to provide the seasonal period <code>m</code> when fitting: <code>fit(spec, data, m=12)</code>.</p><h3 id="Exogenous-Regressors"><a class="docs-heading-anchor" href="#Exogenous-Regressors">Exogenous Regressors</a><a id="Exogenous-Regressors-1"></a><a class="docs-heading-anchor-permalink" href="#Exogenous-Regressors" title="Permalink"></a></h3><h4 id="Explicit-Variables"><a class="docs-heading-anchor" href="#Explicit-Variables">Explicit Variables</a><a id="Explicit-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-Variables" title="Permalink"></a></h4><p>Add regressors (features) by listing column names:</p><pre><code class="language-julia hljs">@formula(sales = p() + q() + price + promotion)</code></pre><p>These become <code>VarTerm</code>s—during fitting, Durbyn pulls the matching columns from your data.</p><h4 id="Automatic-Selection-(auto())"><a class="docs-heading-anchor" href="#Automatic-Selection-(auto())">Automatic Selection (<code>auto()</code>)</a><a id="Automatic-Selection-(auto())-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Selection-(auto())" title="Permalink"></a></h4><p>Use <code>auto()</code> to include all numeric columns as regressors, excluding the response variable (target), group columns, and optional date column:</p><pre><code class="language-julia hljs">@formula(sales = auto())                    # pure auto ARIMA + automatic xregs
@formula(sales = p() + q() + auto())        # combine with explicit ARIMA orders</code></pre><p>Automatic selection is mutually exclusive with explicit exogenous variables or <code>xreg_formula</code>.</p><h4 id="Complex-Designs-(xreg_formula)"><a class="docs-heading-anchor" href="#Complex-Designs-(xreg_formula)">Complex Designs (<code>xreg_formula</code>)</a><a id="Complex-Designs-(xreg_formula)-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-Designs-(xreg_formula)" title="Permalink"></a></h4><p>For interactions or transformations, supply a secondary formula when constructing <code>ArimaSpec</code>:</p><pre><code class="language-julia hljs">spec = ArimaSpec(
    @formula(sales = p() + q()),
    xreg_formula = Formula(&quot;~ temperature * promotion + price^2&quot;)
)</code></pre><p>The <code>xreg_formula</code> is evaluated via <code>Utils.model_matrix</code>, producing the necessary design matrix before fitting.</p><h3 id="ARIMA-Examples"><a class="docs-heading-anchor" href="#ARIMA-Examples">ARIMA Examples</a><a id="ARIMA-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMA-Examples" title="Permalink"></a></h3><p><strong>Fixed orders (fast estimation)</strong>:</p><pre><code class="language-julia hljs">spec = ArimaSpec(@formula(sales = p(1) + d(1) + q(1)))
fitted = fit(spec, (sales = y,))</code></pre><p><strong>Auto ARIMA with search ranges</strong>:</p><pre><code class="language-julia hljs">spec = ArimaSpec(@formula(sales = p(0,3) + d() + q(0,3)))
fitted = fit(spec, (sales = y,))</code></pre><p><strong>Seasonal model with exogenous variables</strong>:</p><pre><code class="language-julia hljs">spec = ArimaSpec(@formula(sales = p() + d() + q() + P() + Q() + price + promotion), m = 12)
fitted = fit(spec, data; m = 12)</code></pre><p><strong>Panel data with automatic xreg</strong>:</p><pre><code class="language-julia hljs">spec = ArimaSpec(@formula(value = p() + d() + q() + P() + Q() + auto()))
panel = PanelData(tbl; groupby = :store, date = :date, m = 12)
fitted = fit(spec, panel)
fc = forecast(fitted, h = 12)</code></pre><hr/><h2 id="ETS-Grammar"><a class="docs-heading-anchor" href="#ETS-Grammar">ETS Grammar</a><a id="ETS-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#ETS-Grammar" title="Permalink"></a></h2><p>The ETS grammar mirrors the ARIMA DSL, letting you describe exponential smoothing models with expressive, composable terms.</p><h3 id="Formula-Basics-2"><a class="docs-heading-anchor" href="#Formula-Basics-2">Formula Basics</a><a class="docs-heading-anchor-permalink" href="#Formula-Basics-2" title="Permalink"></a></h3><p>Use <code>@formula</code> to define the response variable (target) and its ETS components:</p><pre><code class="language-julia hljs">@formula(sales = e(&quot;A&quot;) + t(&quot;N&quot;) + s(&quot;N&quot;))</code></pre><p>Each term is created with helper functions (<code>e</code>, <code>t</code>, <code>s</code>, <code>drift</code>). The resulting formula feeds into <code>EtsSpec</code>.</p><h3 id="Component-Functions"><a class="docs-heading-anchor" href="#Component-Functions">Component Functions</a><a id="Component-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Component-Functions" title="Permalink"></a></h3><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Meaning</th><th style="text-align: right">Accepted Codes</th></tr><tr><td style="text-align: right"><code>e()</code></td><td style="text-align: right">Error component</td><td style="text-align: right"><code>&quot;A&quot;</code> additive, <code>&quot;M&quot;</code> multiplicative, <code>&quot;Z&quot;</code> auto</td></tr><tr><td style="text-align: right"><code>t()</code></td><td style="text-align: right">Trend component</td><td style="text-align: right"><code>&quot;N&quot;</code> none, <code>&quot;A&quot;</code> additive, <code>&quot;M&quot;</code> multiplicative, <code>&quot;Z&quot;</code> auto</td></tr><tr><td style="text-align: right"><code>s()</code></td><td style="text-align: right">Seasonal component</td><td style="text-align: right"><code>&quot;N&quot;</code> none, <code>&quot;A&quot;</code> additive, <code>&quot;M&quot;</code> multiplicative, <code>&quot;Z&quot;</code> auto</td></tr></table><p>Examples:</p><pre><code class="language-julia hljs">e(&quot;A&quot;)              # Additive errors
t(&quot;M&quot;)              # Multiplicative trend
s(&quot;Z&quot;)              # Auto-select seasonal type</code></pre><p>Any component you omit defaults to <code>&quot;Z&quot;</code> (automatic selection). Combine the components as needed for your model structure.</p><h3 id="Damping-and-Drift"><a class="docs-heading-anchor" href="#Damping-and-Drift">Damping and Drift</a><a id="Damping-and-Drift-1"></a><a class="docs-heading-anchor-permalink" href="#Damping-and-Drift" title="Permalink"></a></h3><p>Use <code>drift()</code> to control trend damping:</p><table><tr><th style="text-align: right">Call</th><th style="text-align: right">Effect</th></tr><tr><td style="text-align: right"><code>drift()</code></td><td style="text-align: right">Force a damped trend (<code>damped = true</code>)</td></tr><tr><td style="text-align: right"><code>drift(false)</code></td><td style="text-align: right">Forbid damping (<code>damped = false</code>)</td></tr><tr><td style="text-align: right"><code>drift(:auto)</code></td><td style="text-align: right">Let ETS decide (<code>damped = nothing</code>)</td></tr><tr><td style="text-align: right"><code>drift(&quot;auto&quot;)</code></td><td style="text-align: right">Same as <code>drift(:auto)</code></td></tr></table><p>You can combine <code>drift</code> with any trend choice. When omitted, the ETS search decides whether to include damping.</p><h3 id="Creating-EtsSpec"><a class="docs-heading-anchor" href="#Creating-EtsSpec">Creating <code>EtsSpec</code></a><a id="Creating-EtsSpec-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-EtsSpec" title="Permalink"></a></h3><p>Construct the specification with your formula and optional keywords (passed through to <code>ets</code>):</p><pre><code class="language-julia hljs">spec = EtsSpec(
    @formula(sales = e(&quot;Z&quot;) + t(&quot;A&quot;) + s(&quot;A&quot;) + drift()),
    m = 12,           # seasonal period
    ic = &quot;aicc&quot;       # information criterion for model selection
)

fitted = fit(spec, (sales = sales_vec,); m = 12)
fc = forecast(fitted, h = 12)</code></pre><p>You can override spec options at fit time—keywords supplied to <code>fit</code> take precedence over those stored in the specification.</p><h3 id="ETS-Quick-Recipes"><a class="docs-heading-anchor" href="#ETS-Quick-Recipes">ETS Quick Recipes</a><a id="ETS-Quick-Recipes-1"></a><a class="docs-heading-anchor-permalink" href="#ETS-Quick-Recipes" title="Permalink"></a></h3><p><strong>Simple Exponential Smoothing (SES)</strong>:</p><pre><code class="language-julia hljs">spec = EtsSpec(@formula(value = e(&quot;A&quot;) + t(&quot;N&quot;) + s(&quot;N&quot;)))
fitted = fit(spec, (value = y,))</code></pre><p><strong>Holt&#39;s Linear Trend</strong>:</p><pre><code class="language-julia hljs">spec = EtsSpec(@formula(value = e(&quot;A&quot;) + t(&quot;A&quot;) + s(&quot;N&quot;) + drift(false)))
fitted = fit(spec, (value = y,))</code></pre><p><strong>Holt-Winters (Additive), monthly seasonality</strong>:</p><pre><code class="language-julia hljs">spec = EtsSpec(@formula(value = e(&quot;A&quot;) + t(&quot;A&quot;) + s(&quot;A&quot;) + drift(:auto)), m = 12)
fitted = fit(spec, (value = y,), m = 12)</code></pre><p><strong>Auto ETS with grouped data</strong>:</p><pre><code class="language-julia hljs">spec = EtsSpec(@formula(value = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;Z&quot;)))
fitted = fit(spec, table; groupby = :store, m = 12)
fc = forecast(fitted, h = 8)</code></pre><h3 id="Specialized-ETS-Shortcuts"><a class="docs-heading-anchor" href="#Specialized-ETS-Shortcuts">Specialized ETS Shortcuts</a><a id="Specialized-ETS-Shortcuts-1"></a><a class="docs-heading-anchor-permalink" href="#Specialized-ETS-Shortcuts" title="Permalink"></a></h3><p>You can also target specialized exponential smoothing families directly:</p><pre><code class="language-julia hljs"># Simple Exponential Smoothing
ses_spec = SesSpec(@formula(value = ses()))

# Holt&#39;s linear trend (damped trend forced on)
holt_spec = HoltSpec(@formula(value = holt(damped=true)))

# Holt-Winters with multiplicative seasonality
hw_spec = HoltWintersSpec(@formula(value = hw(seasonal=&quot;multiplicative&quot;)), m = 12)

# Croston&#39;s intermittent-demand method
croston_spec = CrostonSpec(@formula(demand = croston()))</code></pre><p>These specs share the same grouped/PanelData support as <code>EtsSpec</code>, and all options passed via the specification or <code>fit</code> keywords are forwarded to the underlying implementations.</p><hr/><h2 id="Multi-Model-Fitting"><a class="docs-heading-anchor" href="#Multi-Model-Fitting">Multi-Model Fitting</a><a id="Multi-Model-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Model-Fitting" title="Permalink"></a></h2><p>Use <code>ModelCollection</code> to fit multiple specifications simultaneously:</p><pre><code class="language-julia hljs">using Durbyn
using Durbyn.ModelSpecs
using Durbyn.Grammar

# Long table with :series / :date / :value columns
panel = PanelData(tbl; groupby = :series, date = :date, m = 12)

models = model(
    ArimaSpec(@formula(value = p() + q())),
    EtsSpec(@formula(value = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;Z&quot;) + drift(:auto))),
    SesSpec(@formula(value = ses())),
    HoltSpec(@formula(value = holt(damped=true))),
    HoltWintersSpec(@formula(value = hw(seasonal=&quot;multiplicative&quot;)); m = 12),
    CrostonSpec(@formula(value = croston())),
    names = [&quot;arima&quot;, &quot;ets_auto&quot;, &quot;ses&quot;, &quot;holt_damped&quot;, &quot;hw_mul&quot;, &quot;croston&quot;]
)

fitted = fit(models, panel)       # each spec fitted to every series
fc     = forecast(fitted, h = 12) # ForecastModelCollection

forecast_table(fc)                # stacked tidy table with model_name column</code></pre><p><code>forecast_table</code> stacks every model (and group) with a <code>model_name</code> column, so downstream comparisons stay tidy. You can filter to a specific model or pivot wider using <code>Durbyn.TableOps</code> functions, or use other Julia packages like <code>DataFrames.jl</code>, <code>DataFramesMeta.jl</code>, or <code>Query.jl</code>.</p><hr/><h2 id="Complete-End-to-End-Example"><a class="docs-heading-anchor" href="#Complete-End-to-End-Example">Complete End-to-End Example</a><a id="Complete-End-to-End-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-End-to-End-Example" title="Permalink"></a></h2><p>Here&#39;s a comprehensive workflow demonstrating model comparison, forecasting, and accuracy evaluation with panel data:</p><div class="admonition is-info" id="Optional-Dependencies-ecfd9d7c0c0ebd95"><header class="admonition-header">Optional Dependencies<a class="admonition-anchor" href="#Optional-Dependencies-ecfd9d7c0c0ebd95" title="Permalink"></a></header><div class="admonition-body"><p>This example requires <code>CSV</code> and <code>Downloads</code> packages:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add([&quot;CSV&quot;, &quot;Downloads&quot;])</code></pre></div></div><pre><code class="language-julia hljs">using Durbyn, Durbyn.TableOps, Durbyn.Grammar
using CSV, Downloads, Tables

# 1. Load and prepare data
path = Downloads.download(&quot;https://raw.githubusercontent.com/Akai01/example-time-series-datasets/refs/heads/main/Data/retail.csv&quot;)
wide = Tables.columntable(CSV.File(path))

# Reshape to long format
tbl = pivot_longer(wide; id_cols=:date, names_to=:series, values_to=:value)
glimpse(tbl)

# 2. Split into train and test sets
all_dates = unique(tbl.date)
split_date = all_dates[end-11]  # Hold out last 12 periods for testing

train = query(tbl, row -&gt; row.date &lt;= split_date)
test = query(tbl, row -&gt; row.date &gt; split_date)

println(&quot;Training data:&quot;)
glimpse(train)
println(&quot;\nTest data:&quot;)
glimpse(test)

# 3. Create panel data wrapper
panel = PanelData(train; groupby=:series, date=:date, m=12)
glimpse(panel)

# 4. Define multiple models for comparison
models = model(
    ArarSpec(@formula(value = arar())),                                # ARAR via grammar
    ArimaSpec(@formula(value = p() + q())),                              # Auto ARIMA
    EtsSpec(@formula(value = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;Z&quot;) + drift(:auto))),  # Auto ETS with drift
    SesSpec(@formula(value = ses())),                                    # Simple exponential smoothing
    HoltSpec(@formula(value = holt(damped=true))),                       # Damped Holt
    HoltWintersSpec(@formula(value = hw(seasonal=:multiplicative))),     # Holt-Winters multiplicative
    CrostonSpec(@formula(value = croston())),                            # Croston&#39;s method
    names=[&quot;arar&quot;, &quot;arima&quot;, &quot;ets_auto&quot;, &quot;ses&quot;, &quot;holt_damped&quot;, &quot;hw_mul&quot;, &quot;croston&quot;]
)

# 5. Fit all models to all series
fitted = fit(models, panel)

# 6. Generate forecasts (h=12 to match test set)
fc = forecast(fitted, h=12)

# 7. Convert to tidy table format
fc_tbl = forecast_table(fc)
glimpse(fc_tbl)

# 8. Calculate accuracy metrics across all models and series
acc_results = accuracy(fc, test)
println(&quot;\nAccuracy by Series and Model:&quot;)
glimpse(acc_results)

# 9. Visualization
list_series(fc)  # Show available series

# Quick overview of all series for first model
plot(fc, series=:all, facet=true, n_cols=4)

# Detailed inspection with actual values from test set
plot(fc, series=&quot;series_10&quot;, actual=test)

# 10. Find best and worst performing series
# Filter accuracy results for a specific metric (e.g., MAPE)
best_series = acc_results.series[argmin(acc_results.MAPE)]
worst_series = acc_results.series[argmax(acc_results.MAPE)]

# Compare best vs worst performers
plot(fc, series=[best_series, worst_series], facet=true, actual=test)</code></pre><p><strong>Key Features Demonstrated:</strong></p><ul><li><strong>Data preparation</strong>: Download, reshape, and split data using TableOps</li><li><strong>Model comparison</strong>: Fit 7 different forecasting methods simultaneously (ARAR + classical methods)</li><li><strong>Panel forecasting</strong>: Automatic iteration over multiple time series</li><li><strong>Train/test split</strong>: Proper out-of-sample evaluation</li><li><strong>Accuracy metrics</strong>: Compare model performance across series</li><li><strong>Visualization</strong>: Multiple plotting options for analysis</li><li><strong>Tidy output</strong>: Structured forecast tables ready for downstream analysis</li></ul><hr/><h2 id="ARAR-Grammar"><a class="docs-heading-anchor" href="#ARAR-Grammar">ARAR Grammar</a><a id="ARAR-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#ARAR-Grammar" title="Permalink"></a></h2><p>The ARAR grammar exposes the <code>arar()</code> term so you can configure the adaptive-reduction model with the same declarative workflow as ARIMA and ETS.</p><h3 id="Formula-term"><a class="docs-heading-anchor" href="#Formula-term">Formula term</a><a id="Formula-term-1"></a><a class="docs-heading-anchor-permalink" href="#Formula-term" title="Permalink"></a></h3><pre><code class="language-julia hljs">@formula(value = arar())                           # use defaults
@formula(value = arar(max_ar_depth=20))            # custom depth
@formula(value = arar(max_ar_depth=20, max_lag=40))</code></pre><p>Both keywords are optional; if omitted, Durbyn derives appropriate values from the series length. Validation happens at macro-expansion time so mistakes are caught immediately.</p><h3 id="Direct-formula-fitting"><a class="docs-heading-anchor" href="#Direct-formula-fitting">Direct formula fitting</a><a id="Direct-formula-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-formula-fitting" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn
using Durbyn.Ararma

data = (value = air_passengers(),)
formula = @formula(value = arar(max_lag=30))
arar_model = arar(formula, data)          # tables.jl compatible data
fc  = forecast(arar_model; h = 12)</code></pre><p>The estimator lives in the <code>Durbyn.Ararma</code> submodule, so call <code>arar(formula, data)</code> from there (either via <code>using Durbyn.Ararma</code> or <code>Durbyn.Ararma.arar(...)</code>). It works with any Tables.jl source and returns the familiar <code>ARAR</code> struct.</p><h3 id="Model-specification-(ArarSpec)"><a class="docs-heading-anchor" href="#Model-specification-(ArarSpec)">Model specification (<code>ArarSpec</code>)</a><a id="Model-specification-(ArarSpec)-1"></a><a class="docs-heading-anchor-permalink" href="#Model-specification-(ArarSpec)" title="Permalink"></a></h3><p>To leverage grouped fitting, forecasting, and model collections, wrap the formula in <code>ArarSpec</code>:</p><pre><code class="language-julia hljs">spec = ArarSpec(@formula(value = arar(max_ar_depth=15)))
fitted = fit(spec, data)
fc = forecast(fitted; h = 8)</code></pre><p>For panel data:</p><pre><code class="language-julia hljs">panel = PanelData(tbl; groupby = :region)
group_fit = fit(spec, panel)
group_fc = forecast(group_fit; h = 6)</code></pre><p>And to compare against other specs:</p><pre><code class="language-julia hljs">models = model(
    ArarSpec(@formula(value = arar())),
    ArimaSpec(@formula(value = p() + q())),
    EtsSpec(@formula(value = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;Z&quot;))),
    names = [&quot;arar&quot;, &quot;arima&quot;, &quot;ets&quot;]
)

fitted = fit(models, panel)
fc = forecast(fitted; h = 12)</code></pre><p>The ARAR grammar therefore integrates seamlessly with every Durbyn workflow—single series, grouped/panel data, and large-scale model comparisons.</p><hr/><h2 id="ARARMA-Grammar"><a class="docs-heading-anchor" href="#ARARMA-Grammar">ARARMA Grammar</a><a id="ARARMA-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#ARARMA-Grammar" title="Permalink"></a></h2><p>The ARARMA grammar extends the ARAR approach by fitting a short-memory ARMA(p,q) model after the adaptive reduction stage. Like ARIMA, it uses the <code>p()</code> and <code>q()</code> terms to specify model orders, but the distinction comes from using <code>ArarmaSpec</code> instead of <code>ArimaSpec</code>.</p><h3 id="Formula-terms"><a class="docs-heading-anchor" href="#Formula-terms">Formula terms</a><a id="Formula-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Formula-terms" title="Permalink"></a></h3><p>ARARMA reuses ARIMA&#39;s order grammar:</p><pre><code class="language-julia hljs">@formula(value = p() + q())                    # auto selection with defaults
@formula(value = p(1) + q(2))                  # fixed ARARMA(1,2)
@formula(value = p(0,3) + q(0,2))              # search ranges</code></pre><p><strong>Key differences from ARIMA:</strong></p><ul><li>ARARMA does <strong>not</strong> support <code>d()</code>, <code>D()</code>, <code>P()</code>, or <code>Q()</code> terms (differencing is handled by the ARAR stage)</li><li>ARARMA does <strong>not</strong> support exogenous regressors (no variables, no <code>auto()</code>)</li><li>ARARMA adds ARAR-specific parameters: <code>max_ar_depth</code> and <code>max_lag</code></li></ul><h3 id="Automatic-vs-Fixed-Order-Selection"><a class="docs-heading-anchor" href="#Automatic-vs-Fixed-Order-Selection">Automatic vs Fixed Order Selection</a><a id="Automatic-vs-Fixed-Order-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-vs-Fixed-Order-Selection" title="Permalink"></a></h3><p><strong>If ANY order is a range</strong> → uses <code>auto_ararma()</code>:</p><ul><li><code>p() + q()</code> → searches with defaults (p: 0-4, q: 0-2)</li><li><code>p(0,3) + q()</code> → searches p ∈ {0,1,2,3}, q with defaults</li><li><code>p(1) + q(0,2)</code> → searches q ∈ {0,1,2} with fixed p=1</li></ul><p><strong>If ALL orders are fixed</strong> → uses <code>ararma()</code> directly (faster):</p><ul><li><code>p(1) + q(2)</code> → fits ARARMA(1,2) without search</li></ul><h3 id="Direct-formula-fitting-2"><a class="docs-heading-anchor" href="#Direct-formula-fitting-2">Direct formula fitting</a><a class="docs-heading-anchor-permalink" href="#Direct-formula-fitting-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn
using Durbyn.Ararma

data = (value = air_passengers(),)

# Fixed ARARMA(1,2)
formula = @formula(value = p(1) + q(2))
ararma_model = ararma(formula, data)
fc = forecast(ararma_model; h = 12)

# Auto ARARMA with custom parameters
formula = @formula(value = p() + q())
ararma_model = ararma(formula, data, max_ar_depth=20, max_lag=30, crit=:bic)
fc = forecast(ararma_model; h = 12)</code></pre><p>The estimator lives in the <code>Durbyn.Ararma</code> submodule. It works with any Tables.jl source and returns an <code>ArarmaModel</code> struct.</p><h3 id="Model-specification-(ArarmaSpec)"><a class="docs-heading-anchor" href="#Model-specification-(ArarmaSpec)">Model specification (<code>ArarmaSpec</code>)</a><a id="Model-specification-(ArarmaSpec)-1"></a><a class="docs-heading-anchor-permalink" href="#Model-specification-(ArarmaSpec)" title="Permalink"></a></h3><p>To leverage grouped fitting, forecasting, and model collections, wrap the formula in <code>ArarmaSpec</code>:</p><pre><code class="language-julia hljs"># Fixed ARARMA(2,1)
spec = ArarmaSpec(@formula(value = p(2) + q(1)))
fitted = fit(spec, data)
fc = forecast(fitted; h = 8)

# Auto ARARMA with custom ARAR parameters
spec = ArarmaSpec(
    @formula(value = p() + q()),
    max_ar_depth = 20,
    max_lag = 30,
    crit = :bic
)
fitted = fit(spec, data)
fc = forecast(fitted; h = 12)</code></pre><p>For panel data:</p><pre><code class="language-julia hljs">panel = PanelData(tbl; groupby = :region, m = m)
spec = ArarmaSpec(@formula(value = p(1) + q(1)))
group_fit = fit(spec, panel)
group_fc = forecast(group_fit; h = 6)</code></pre><p>And to compare against other specs:</p><pre><code class="language-julia hljs">models = model(
    ArarmaSpec(@formula(value = p() + q())),
    ArarSpec(@formula(value = arar())),
    ArimaSpec(@formula(value = p() + q() + P() + Q())),
    EtsSpec(@formula(value = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;Z&quot;))),
    names = [&quot;ararma&quot;, &quot;arar&quot;, &quot;arima&quot;, &quot;ets&quot;]
)

fitted = fit(models, panel)
fc = forecast(fitted; h = 12)</code></pre><p>The ARARMA grammar therefore integrates seamlessly with every Durbyn workflow—single series, grouped/panel data, and large-scale model comparisons.</p><hr/><h2 id="Tips-and-Best-Practices"><a class="docs-heading-anchor" href="#Tips-and-Best-Practices">Tips and Best Practices</a><a id="Tips-and-Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Tips-and-Best-Practices" title="Permalink"></a></h2><h3 id="ARIMA-Tips"><a class="docs-heading-anchor" href="#ARIMA-Tips">ARIMA Tips</a><a id="ARIMA-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMA-Tips" title="Permalink"></a></h3><ul><li>Any range triggers automatic model selection</li><li>Fixed orders call fast direct estimation</li><li>Exogenous support includes explicit columns, <code>auto()</code>, or complex formulas</li><li>Combine with <code>PanelData</code> to store group/date metadata cleanly</li><li>If you omit <code>newdata</code> when forecasting, Durbyn reuses each group&#39;s most recent exogenous values</li></ul><h3 id="ETS-Tips"><a class="docs-heading-anchor" href="#ETS-Tips">ETS Tips</a><a id="ETS-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#ETS-Tips" title="Permalink"></a></h3><ul><li>Always specify <code>m</code> (seasonal period) when you expect seasonal behavior. If you omit it, ETS defaults to <code>m = 1</code></li><li>Keywords like <code>lambda</code>, <code>alpha</code>, or <code>ic</code> are forwarded directly to the underlying <code>ets</code> implementation</li><li>Grouped fits reuse the same grammar—<code>fit(spec, data; groupby = [:region])</code> returns <code>GroupedFittedModels</code></li><li>Forecast works the same way for both single and grouped models</li></ul><h3 id="General-Tips"><a class="docs-heading-anchor" href="#General-Tips">General Tips</a><a id="General-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#General-Tips" title="Permalink"></a></h3><ul><li>Use <code>PanelData</code> to encapsulate grouping, date, and seasonal period information</li><li>Specifications are reusable—define once, fit to multiple datasets</li><li>Keywords in <code>fit()</code> override those stored in the spec</li><li><code>forecast_table()</code> provides tidy output for downstream analysis and visualization</li><li>Combine multiple specs in a <code>ModelCollection</code> for easy model comparison</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Quick Start</a><a class="docs-footer-nextpage" href="../expsmoothing/">Exponential Smoothing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 7 November 2025 12:40">Friday 7 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
