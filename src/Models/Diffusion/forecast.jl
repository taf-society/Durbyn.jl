"""
    Diffusion Model Forecasting

Functions to generate forecasts from fitted diffusion models.
"""

"""
    forecast(fit::DiffusionFit; h::Int, level::Vector{Int}=[80, 95]) -> Forecast

Generate forecasts from a fitted diffusion model.

# Arguments
- `fit::DiffusionFit`: A fitted diffusion model

# Keyword Arguments
- `h::Int`: Forecast horizon (number of periods to forecast)
- `level::Vector{Int}=[80, 95]`: Confidence levels for prediction intervals

# Returns
A `Forecast` object containing point forecasts and prediction intervals.

# Details
Point forecasts are generated by extending the diffusion curve h periods beyond
the observed (cleaned) data. When cleanlead=true was used during fitting, the
forecast time origin is adjusted to account for removed leading zeros.

Prediction intervals are computed using residual-based variance estimation
with normal approximation.

# Example
```julia
y = [5, 10, 25, 45, 70, 85, 75, 50, 30, 15]
fit = diffusion(y, model_type=Bass)
fc = forecast(fit, h=5)

fc.mean        # Point forecasts
fc.lower[1]    # 80% lower bounds
fc.upper[2]    # 95% upper bounds
```
"""
function forecast(fit::DiffusionFit; h::Int, level::Vector{Int}=[80, 95])
    n = length(fit.y)  # Length of cleaned data

    # Generate extended curve from t=1 (adjusted time origin after offset removal)
    n_extended = n + h
    curve = get_curve(fit.model_type, n_extended, fit.params)

    # Extract forecast portion
    forecasts = curve.adoption[(n+1):n_extended]

    # Compute prediction intervals
    intervals = compute_prediction_intervals(fit, h, level)

    lower = [intervals["lo_$lv"] for lv in level]
    upper = [intervals["hi_$lv"] for lv in level]

    method = "Diffusion($(fit.model_type))"

    return Forecast(
        fit,
        method,
        forecasts,
        level,
        fit.y,
        upper,
        lower,
        fit.fitted,
        fit.residuals
    )
end

"""
    compute_prediction_intervals(fit, h, level; n_samples=1000) -> Dict

Compute prediction intervals for diffusion forecasts.

Uses residual variance estimation with normal approximation.
For adoption data, variance typically increases then decreases with the
curve shape, so we scale by the predicted mean.

# Arguments
- `fit::DiffusionFit`: Fitted model
- `h::Int`: Forecast horizon
- `level::Vector{Int}`: Confidence levels

# Returns
Dictionary with keys "lo_XX" and "hi_XX" for each confidence level.
"""
function compute_prediction_intervals(fit::DiffusionFit, h::Int, level::Vector{Int})
    T = Float64
    n = length(fit.y)

    # Compute residual standard deviation (using corrected variance)
    valid_residuals = fit.residuals[fit.residuals .!= 0]
    if length(valid_residuals) < 2
        sigma = T(1.0)
    else
        sigma = std(valid_residuals, corrected=true)
    end

    # Generate extended curve for forecast values
    n_extended = n + h
    curve = get_curve(fit.model_type, n_extended, fit.params)
    forecasts = curve.adoption[(n+1):n_extended]

    # For diffusion models, prediction uncertainty can scale with the forecast magnitude
    # Use a combination of constant variance and proportional variance
    cv = sigma / max(mean(abs.(fit.fitted)), T(1e-10))  # Coefficient of variation

    intervals = Dict{String, Vector{T}}()

    for lv in level
        alpha = (100 - lv) / 100
        z = _quantile_normal(1 - alpha / 2)

        # Scale standard error with forecast magnitude but add floor
        se = max.(sigma, cv .* abs.(forecasts))

        intervals["lo_$lv"] = max.(forecasts .- z .* se, T(0.0))
        intervals["hi_$lv"] = forecasts .+ z .* se
    end

    return intervals
end

"""
    _quantile_normal(p) -> Float64

Compute the p-th quantile of the standard normal distribution.
Uses Abramowitz and Stegun approximation.
"""
function _quantile_normal(p::Real)
    T = Float64
    p = T(p)

    # Handle edge cases
    if p <= 0
        return T(-Inf)
    elseif p >= 1
        return T(Inf)
    elseif p == 0.5
        return T(0.0)
    end

    # Rational approximation constants (Abramowitz and Stegun 26.2.23)
    a = [
        -3.969683028665376e+01,
         2.209460984245205e+02,
        -2.759285104469687e+02,
         1.383577518672690e+02,
        -3.066479806614716e+01,
         2.506628277459239e+00
    ]
    b = [
        -5.447609879822406e+01,
         1.615858368580409e+02,
        -1.556989798598866e+02,
         6.680131188771972e+01,
        -1.328068155288572e+01
    ]
    c = [
        -7.784894002430293e-03,
        -3.223964580411365e-01,
        -2.400758277161838e+00,
        -2.549732539343734e+00,
         4.374664141464968e+00,
         2.938163982698783e+00
    ]
    d = [
         7.784695709041462e-03,
         3.224671290700398e-01,
         2.445134137142996e+00,
         3.754408661907416e+00
    ]

    p_low = T(0.02425)
    p_high = T(1.0) - p_low

    if p < p_low
        # Rational approximation for lower region
        q = sqrt(-2 * log(p))
        return (((((c[1]*q + c[2])*q + c[3])*q + c[4])*q + c[5])*q + c[6]) /
               ((((d[1]*q + d[2])*q + d[3])*q + d[4])*q + 1)
    elseif p <= p_high
        # Rational approximation for central region
        q = p - T(0.5)
        r = q * q
        return (((((a[1]*r + a[2])*r + a[3])*r + a[4])*r + a[5])*r + a[6])*q /
               (((((b[1]*r + b[2])*r + b[3])*r + b[4])*r + b[5])*r + 1)
    else
        # Rational approximation for upper region
        q = sqrt(-2 * log(1 - p))
        return -(((((c[1]*q + c[2])*q + c[3])*q + c[4])*q + c[5])*q + c[6]) /
                ((((d[1]*q + d[2])*q + d[3])*q + d[4])*q + 1)
    end
end

"""
    predict(fit::DiffusionFit, t::AbstractVector{<:Real}) -> NamedTuple

Predict adoption values at specific time points.

# Arguments
- `fit::DiffusionFit`: Fitted model
- `t::Vector`: Time points at which to predict

# Returns
NamedTuple with `adoption` and `cumulative` predictions.

# Example
```julia
fit = diffusion(y, model_type=Bass)
pred = predict(fit, 1:20)  # Predict for periods 1-20
```
"""
function predict(fit::DiffusionFit, t::AbstractVector{<:Real})
    n_max = maximum(Int, t)

    # Generate curve up to max time point
    curve = get_curve(fit.model_type, n_max, fit.params)

    # Extract values at requested time points
    t_int = Int.(t)
    adoption = [curve.adoption[i] for i in t_int]
    cumulative = [curve.cumulative[i] for i in t_int]

    return (adoption=adoption, cumulative=cumulative)
end
