<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Naive Methods · Durbyn.jl</title><meta name="title" content="Naive Methods · Durbyn.jl"/><meta property="og:title" content="Naive Methods · Durbyn.jl"/><meta property="twitter:title" content="Naive Methods · Durbyn.jl"/><meta name="description" content="Documentation for Durbyn.jl."/><meta property="og:description" content="Documentation for Durbyn.jl."/><meta property="twitter:description" content="Documentation for Durbyn.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/theme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Durbyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Durbyn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../grammar/">Grammar</a></li><li class="is-active"><a class="tocitem" href>Naive Methods</a><ul class="internal"><li><a class="tocitem" href="#Formula-Interface-(primary-usage)"><span>Formula Interface (primary usage)</span></a></li><li><a class="tocitem" href="#Base-API-(array-interface)"><span>Base API (array interface)</span></a></li><li><a class="tocitem" href="#Methodology"><span>Methodology</span></a></li><li><a class="tocitem" href="#Prediction-Intervals"><span>Prediction Intervals</span></a></li><li><a class="tocitem" href="#When-to-Use-Each-Method"><span>When to Use Each Method</span></a></li><li><a class="tocitem" href="#Missing-Value-Handling"><span>Missing Value Handling</span></a></li><li><a class="tocitem" href="#Box-Cox-Transformation"><span>Box-Cox Transformation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../expsmoothing/">Exponential Smoothing</a></li><li><a class="tocitem" href="../theta/">Theta</a></li><li><a class="tocitem" href="../bats/">BATS</a></li><li><a class="tocitem" href="../tbats/">TBATS</a></li><li><a class="tocitem" href="../intermittent/">Intermittent Demand</a></li><li><a class="tocitem" href="../arima/">ARIMA</a></li><li><a class="tocitem" href="../diffusion/">Diffusion</a></li><li><a class="tocitem" href="../arar/">ARAR</a></li><li><a class="tocitem" href="../ararma/">ARARMA</a></li><li><a class="tocitem" href="../stats/">Statistics</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../tableops/">Table Operations</a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Naive Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Naive Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/taf-society/Durbyn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/taf-society/Durbyn.jl/blob/main/docs/src/naive.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Naive-Forecasting-Methods"><a class="docs-heading-anchor" href="#Naive-Forecasting-Methods">Naive Forecasting Methods</a><a id="Naive-Forecasting-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Naive-Forecasting-Methods" title="Permalink"></a></h1><div class="admonition is-success" id="Formula-Interface-is-the-Recommended-Approach-71eddfa4525d2e98"><header class="admonition-header">Formula Interface is the Recommended Approach<a class="admonition-anchor" href="#Formula-Interface-is-the-Recommended-Approach-71eddfa4525d2e98" title="Permalink"></a></header><div class="admonition-body"><p>Use <code>NaiveSpec</code>, <code>SnaiveSpec</code>, <code>RwSpec</code>, or <code>MeanfSpec</code> with <code>@formula</code> for a declarative interface that works with panel data, grouped fitting, and model comparison. The base (array) API is shown near the end.</p></div></div><p>Naive forecasting methods serve as simple <strong>benchmark models</strong> for more complex forecasting approaches. Despite their simplicity, they often perform surprisingly well, especially for highly volatile or unpredictable data. Durbyn implements four naive methods:</p><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Function</th><th style="text-align: right">Description</th><th style="text-align: right">Best for</th></tr><tr><td style="text-align: right"><strong>Naive</strong></td><td style="text-align: right"><code>naive()</code></td><td style="text-align: right">Uses last observation as forecast</td><td style="text-align: right">Random walk data, benchmarks</td></tr><tr><td style="text-align: right"><strong>Seasonal Naive</strong></td><td style="text-align: right"><code>snaive()</code></td><td style="text-align: right">Uses observation from m periods ago</td><td style="text-align: right">Strong seasonal patterns</td></tr><tr><td style="text-align: right"><strong>Random Walk with Drift</strong></td><td style="text-align: right"><code>rw(drift=true)</code></td><td style="text-align: right">Naive + linear trend</td><td style="text-align: right">Trending data</td></tr><tr><td style="text-align: right"><strong>Mean</strong></td><td style="text-align: right"><code>meanf()</code></td><td style="text-align: right">Uses sample mean as forecast</td><td style="text-align: right">Stationary data</td></tr></table><hr/><h2 id="Formula-Interface-(primary-usage)"><a class="docs-heading-anchor" href="#Formula-Interface-(primary-usage)">Formula Interface (primary usage)</a><a id="Formula-Interface-(primary-usage)-1"></a><a class="docs-heading-anchor-permalink" href="#Formula-Interface-(primary-usage)" title="Permalink"></a></h2><h3 id="Example-1:-Naive-forecast"><a class="docs-heading-anchor" href="#Example-1:-Naive-forecast">Example 1: Naive forecast</a><a id="Example-1:-Naive-forecast-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Naive-forecast" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn, Durbyn.Grammar

data = (sales = [120, 135, 148, 152, 141, 158, 170, 165, 180, 195],)

# Naive: forecast = last observation
spec = NaiveSpec(@formula(sales = naive_term()))
fitted = fit(spec, data)
fc = forecast(fitted, h = 12)</code></pre><h3 id="Example-2:-Seasonal-naive-forecast"><a class="docs-heading-anchor" href="#Example-2:-Seasonal-naive-forecast">Example 2: Seasonal naive forecast</a><a id="Example-2:-Seasonal-naive-forecast-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Seasonal-naive-forecast" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn, Durbyn.Grammar

# Monthly sales data with yearly seasonality
data = (sales = [100, 110, 125, 140, 155, 170,
                 160, 150, 135, 120, 105, 95,
                 105, 115, 130, 145, 160, 175,
                 165, 155, 140, 125, 110, 100],)

# Seasonal naive: forecast = value from same month last year
spec = SnaiveSpec(@formula(sales = snaive_term()), m = 12)
fitted = fit(spec, data)
fc = forecast(fitted, h = 12)</code></pre><h3 id="Example-3:-Random-walk-with-drift"><a class="docs-heading-anchor" href="#Example-3:-Random-walk-with-drift">Example 3: Random walk with drift</a><a id="Example-3:-Random-walk-with-drift-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Random-walk-with-drift" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn, Durbyn.Grammar

# Trending data
data = (value = cumsum(randn(50) .+ 0.5),)

# RW with drift: forecast = last value + h * average change
spec = RwSpec(@formula(value = rw_term(drift = true)))
fitted = fit(spec, data)
fc = forecast(fitted, h = 10)

# Access drift coefficient
fitted.fit.drift      # Drift value
fitted.fit.drift_se   # Drift standard error</code></pre><h3 id="Example-4:-Mean-forecast"><a class="docs-heading-anchor" href="#Example-4:-Mean-forecast">Example 4: Mean forecast</a><a id="Example-4:-Mean-forecast-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Mean-forecast" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn, Durbyn.Grammar

# Stationary data around a mean
data = (temp = 20.0 .+ randn(100),)

# Mean: forecast = sample mean for all horizons
spec = MeanfSpec(@formula(temp = meanf_term()))
fitted = fit(spec, data, m = 12)
fc = forecast(fitted, h = 12)

# Access mean
fitted.fit.mu_original  # Mean on original scale</code></pre><h3 id="Example-5:-Model-comparison"><a class="docs-heading-anchor" href="#Example-5:-Model-comparison">Example 5: Model comparison</a><a id="Example-5:-Model-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Example-5:-Model-comparison" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn, Durbyn.Grammar

data = (y = [100, 105, 102, 108, 115, 120, 118, 125, 130, 128],)

# Compare naive methods
naive_spec = NaiveSpec(@formula(y = naive_term()))
rw_spec = RwSpec(@formula(y = rw_term(drift = true)))
mean_spec = MeanfSpec(@formula(y = meanf_term()))

naive_fit = fit(naive_spec, data)
rw_fit = fit(rw_spec, data)
mean_fit = fit(mean_spec, data, m = 1)

# Compare residual variance
naive_fit.fit.sigma2  # Naive residual variance
rw_fit.fit.sigma2     # RW with drift residual variance</code></pre><h3 id="Example-6:-Panel-data-/-grouped-fitting"><a class="docs-heading-anchor" href="#Example-6:-Panel-data-/-grouped-fitting">Example 6: Panel data / grouped fitting</a><a id="Example-6:-Panel-data-/-grouped-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Example-6:-Panel-data-/-grouped-fitting" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn, Durbyn.TableOps, Durbyn.ModelSpecs, Durbyn.Grammar

# Stacked table with :product column
panel = PanelData(tbl; groupby = :product, date = :date, m = 12)

# Fit seasonal naive to each group
spec = SnaiveSpec(@formula(sales = snaive_term()))
fitted = fit(spec, panel)
fc = forecast(fitted, h = 12)</code></pre><h3 id="Example-7:-Box-Cox-transformation"><a class="docs-heading-anchor" href="#Example-7:-Box-Cox-transformation">Example 7: Box-Cox transformation</a><a id="Example-7:-Box-Cox-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-7:-Box-Cox-transformation" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn, Durbyn.Grammar

# Positive data with increasing variance
data = (sales = exp.(cumsum(randn(50) .* 0.1 .+ 0.05)),)

# Apply log transformation (lambda = 0) with bias adjustment
spec = NaiveSpec(@formula(sales = naive_term()), lambda = 0.0, biasadj = true)
fitted = fit(spec, data)
fc = forecast(fitted, h = 12)</code></pre><hr/><h2 id="Base-API-(array-interface)"><a class="docs-heading-anchor" href="#Base-API-(array-interface)">Base API (array interface)</a><a id="Base-API-(array-interface)-1"></a><a class="docs-heading-anchor-permalink" href="#Base-API-(array-interface)" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Durbyn

y = randn(100)

# Naive forecast
fit_naive = naive(y)
fc = forecast(fit_naive; h = 12)

# Seasonal naive (monthly data)
y_seasonal = repeat([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 3)
fit_snaive = snaive(y_seasonal, 12)
fc = forecast(fit_snaive; h = 24)

# Random walk with drift
y_trend = cumsum(randn(100))
fit_rw = rw(y_trend; drift = true)
fc = forecast(fit_rw; h = 10)

# Mean forecast
fit_mean = meanf(y, 1)
fc = forecast(fit_mean, 12)</code></pre><p><code>NaiveFit</code> exposes <code>fitted</code>, <code>residuals</code>, <code>sigma2</code>, <code>lag</code>, <code>drift</code>, <code>drift_se</code>, and optional Box-Cox parameters (<code>lambda</code>, <code>biasadj</code>).</p><hr/><h2 id="Methodology"><a class="docs-heading-anchor" href="#Methodology">Methodology</a><a id="Methodology-1"></a><a class="docs-heading-anchor-permalink" href="#Methodology" title="Permalink"></a></h2><h3 id="Naive-Method"><a class="docs-heading-anchor" href="#Naive-Method">Naive Method</a><a id="Naive-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Naive-Method" title="Permalink"></a></h3><p>The naive forecast uses the last observed value as the forecast for all future horizons:</p><p class="math-container">\[\hat{y}_{T+h|T} = y_T \quad \text{for all } h = 1, 2, \ldots\]</p><p>This is equivalent to a random walk model without drift.</p><h3 id="Seasonal-Naive-Method"><a class="docs-heading-anchor" href="#Seasonal-Naive-Method">Seasonal Naive Method</a><a id="Seasonal-Naive-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Seasonal-Naive-Method" title="Permalink"></a></h3><p>The seasonal naive method uses the observation from the same season in the previous cycle:</p><p class="math-container">\[\hat{y}_{T+h|T} = y_{T+h-m \cdot k}\]</p><p>where <span>$m$</span> is the seasonal period and <span>$k = \lceil h/m \rceil$</span> is the number of complete seasonal cycles back.</p><p>For example, with monthly data (<span>$m = 12$</span>), the forecast for January next year uses the value from January this year.</p><h3 id="Random-Walk-with-Drift"><a class="docs-heading-anchor" href="#Random-Walk-with-Drift">Random Walk with Drift</a><a id="Random-Walk-with-Drift-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Walk-with-Drift" title="Permalink"></a></h3><p>The random walk with drift includes a linear trend based on the average historical change:</p><p class="math-container">\[\hat{y}_{T+h|T} = y_T + h \cdot b\]</p><p>where the drift term <span>$b$</span> is estimated as the mean of first differences:</p><p class="math-container">\[b = \frac{1}{n}\sum_{t=2}^{T} (y_t - y_{t-1})\]</p><p>where <span>$n$</span> is the number of valid consecutive pairs. This approach is more robust than the endpoint formula <span>$(y_T - y_1)/(T-1)$</span> because it uses all available consecutive pairs rather than just endpoints, making it more reliable when data has missing values or gaps.</p><h3 id="Mean-Method"><a class="docs-heading-anchor" href="#Mean-Method">Mean Method</a><a id="Mean-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-Method" title="Permalink"></a></h3><p>The mean method uses the historical average as the forecast:</p><p class="math-container">\[\hat{y}_{T+h|T} = \bar{y} = \frac{1}{T}\sum_{t=1}^{T} y_t\]</p><p>This assumes the data fluctuates around a constant mean with no trend or seasonality.</p><hr/><h2 id="Prediction-Intervals"><a class="docs-heading-anchor" href="#Prediction-Intervals">Prediction Intervals</a><a id="Prediction-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Prediction-Intervals" title="Permalink"></a></h2><p>Naive methods produce prediction intervals that widen with the forecast horizon, reflecting increasing uncertainty over time.</p><p><strong>Residual variance (<span>$σ²$</span>)</strong>: The residual variance used for prediction intervals is computed as the mean squared error (MSE) of residuals without centering: <span>$σ² = \frac{1}{n}\sum_{t} e_t^2$</span>. This matches R&#39;s forecast package behavior.</p><h3 id="Naive-/-Random-Walk-(without-drift)"><a class="docs-heading-anchor" href="#Naive-/-Random-Walk-(without-drift)">Naive / Random Walk (without drift)</a><a id="Naive-/-Random-Walk-(without-drift)-1"></a><a class="docs-heading-anchor-permalink" href="#Naive-/-Random-Walk-(without-drift)" title="Permalink"></a></h3><p>Forecast variance grows linearly with horizon:</p><p class="math-container">\[\text{Var}(\hat{y}_{T+h|T}) = h \cdot \sigma^2\]</p><p>The standard error is:</p><p class="math-container">\[\text{SE}(h) = \sqrt{h} \cdot \sigma\]</p><h3 id="Seasonal-Naive"><a class="docs-heading-anchor" href="#Seasonal-Naive">Seasonal Naive</a><a id="Seasonal-Naive-1"></a><a class="docs-heading-anchor-permalink" href="#Seasonal-Naive" title="Permalink"></a></h3><p>Variance increases with the number of complete seasonal cycles:</p><p class="math-container">\[\text{Var}(\hat{y}_{T+h|T}) = \lceil h/m \rceil \cdot \sigma^2\]</p><p>where <span>$m$</span> is the seasonal period. The variance increases in steps each time a new seasonal cycle is entered.</p><h3 id="Random-Walk-with-Drift-2"><a class="docs-heading-anchor" href="#Random-Walk-with-Drift-2">Random Walk with Drift</a><a class="docs-heading-anchor-permalink" href="#Random-Walk-with-Drift-2" title="Permalink"></a></h3><p>Includes additional uncertainty from the drift estimate:</p><p class="math-container">\[\text{Var}(\hat{y}_{T+h|T}) = h \cdot \sigma^2 + h^2 \cdot \text{SE}(b)^2\]</p><p>where <span>$\text{SE}(b) = s_d / \sqrt{n}$</span> is the standard error of the drift coefficient, <span>$s_d$</span> is the standard deviation of the first differences, and <span>$n$</span> is the number of valid consecutive pairs.</p><h3 id="Mean-Method-2"><a class="docs-heading-anchor" href="#Mean-Method-2">Mean Method</a><a class="docs-heading-anchor-permalink" href="#Mean-Method-2" title="Permalink"></a></h3><p>Uses the t-distribution for intervals:</p><p class="math-container">\[\hat{y}_{T+h|T} \pm t_{1-\alpha/2, T-1} \cdot s \cdot \sqrt{1 + 1/T}\]</p><p>where <span>$s$</span> is the sample standard deviation and <span>$T$</span> is the number of observations.</p><hr/><h2 id="When-to-Use-Each-Method"><a class="docs-heading-anchor" href="#When-to-Use-Each-Method">When to Use Each Method</a><a id="When-to-Use-Each-Method-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Each-Method" title="Permalink"></a></h2><table><tr><th style="text-align: right">Scenario</th><th style="text-align: right">Recommended Method</th></tr><tr><td style="text-align: right">No clear pattern, random fluctuations</td><td style="text-align: right"><code>naive()</code></td></tr><tr><td style="text-align: right">Strong, stable seasonal pattern</td><td style="text-align: right"><code>snaive()</code></td></tr><tr><td style="text-align: right">Clear upward or downward trend</td><td style="text-align: right"><code>rw(drift=true)</code></td></tr><tr><td style="text-align: right">Stationary data around a level</td><td style="text-align: right"><code>meanf()</code></td></tr><tr><td style="text-align: right">Benchmark for complex models</td><td style="text-align: right">Any naive method</td></tr></table><div class="admonition is-info" id="Benchmarking-Best-Practice-8a4933747975252"><header class="admonition-header">Benchmarking Best Practice<a class="admonition-anchor" href="#Benchmarking-Best-Practice-8a4933747975252" title="Permalink"></a></header><div class="admonition-body"><p>Always compare your forecast model against naive benchmarks. If a sophisticated model cannot beat the seasonal naive method, consider whether the added complexity is justified.</p></div></div><hr/><h2 id="Missing-Value-Handling"><a class="docs-heading-anchor" href="#Missing-Value-Handling">Missing Value Handling</a><a id="Missing-Value-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-Value-Handling" title="Permalink"></a></h2><p>All naive methods handle missing values gracefully:</p><ul><li><strong>Leading missings</strong>: Skipped when finding the starting point</li><li><strong>Trailing missings</strong>: The last valid observation is used</li><li><strong>Scattered missings</strong>: Converted to NaN internally; fitted values use forward-fill from the most recent valid lagged value</li></ul><pre><code class="language-julia hljs">y = [1.0, missing, 3.0, 4.0, missing, 6.0]
fit = naive(y)  # Uses 6.0 (last valid) for forecasts
# fit.fitted[3] = 1.0 (lagged from y[1], since y[2] is missing)</code></pre><p><strong>Forward-fill behavior</strong>: When computing fitted values, if the lagged value is missing, the method forward-fills from the most recent valid fitted value. This matches the R forecast package&#39;s <code>lagwalk()</code> behavior and ensures fitted values are available wherever actual values exist, even when there are gaps in the series.</p><p>For seasonal naive, if a particular seasonal position has missing values, the method searches backwards through prior seasonal cycles to find the most recent valid observation at that position.</p><hr/><h2 id="Box-Cox-Transformation"><a class="docs-heading-anchor" href="#Box-Cox-Transformation">Box-Cox Transformation</a><a id="Box-Cox-Transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Box-Cox-Transformation" title="Permalink"></a></h2><p>All naive methods support Box-Cox transformation for variance stabilization:</p><pre><code class="language-julia hljs"># Log transformation (lambda = 0)
fit = naive(y; lambda = 0.0)

# Square root transformation (lambda = 0.5)
fit = naive(y; lambda = 0.5)

# Automatic lambda selection
fit = naive(y; lambda = &quot;auto&quot;)

# With bias adjustment for back-transformation
fit = naive(y; lambda = 0.0, biasadj = true)</code></pre><p><strong>Lambda requirements</strong>:</p><ul><li><span>$λ ≤ 0$</span>: Requires strictly positive values (non-positive values are treated as missing with a warning)</li><li><span>$λ &gt; 0$</span>: Allows negative values and zeros via signed transformation<ul><li>For x=0: the transform produces <span>$-1/λ$</span> (finite value)</li></ul></li></ul><p>The <code>biasadj</code> option applies a bias correction when transforming forecasts back to the original scale, which can improve accuracy for skewed distributions. When enabled, bias adjustment is applied to both fitted values and point forecasts.</p><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li>Hyndman, R. J., &amp; Athanasopoulos, G. (2021). <em>Forecasting: Principles and Practice</em> (3rd ed.). OTexts. <a href="https://otexts.com/fpp3/">https://otexts.com/fpp3/</a></li><li>Makridakis, S., Wheelwright, S. C., &amp; Hyndman, R. J. (1998). <em>Forecasting: Methods and Applications</em> (3rd ed.). John Wiley &amp; Sons.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../grammar/">« Grammar</a><a class="docs-footer-nextpage" href="../expsmoothing/">Exponential Smoothing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 13 February 2026 14:31">Friday 13 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
