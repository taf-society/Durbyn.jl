<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Statistics · Durbyn.jl</title><meta name="title" content="Statistics · Durbyn.jl"/><meta property="og:title" content="Statistics · Durbyn.jl"/><meta property="twitter:title" content="Statistics · Durbyn.jl"/><meta name="description" content="Documentation for Durbyn.jl."/><meta property="og:description" content="Documentation for Durbyn.jl."/><meta property="twitter:description" content="Documentation for Durbyn.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/theme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Durbyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Durbyn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../grammar/">Grammar</a></li><li><a class="tocitem" href="../expsmoothing/">Exponential Smoothing</a></li><li><a class="tocitem" href="../theta/">Theta</a></li><li><a class="tocitem" href="../bats/">BATS</a></li><li><a class="tocitem" href="../tbats/">TBATS</a></li><li><a class="tocitem" href="../intermittent/">Intermittent Demand</a></li><li><a class="tocitem" href="../arima/">ARIMA</a></li><li><a class="tocitem" href="../arar/">ARAR</a></li><li><a class="tocitem" href="../ararma/">ARARMA</a></li><li class="is-active"><a class="tocitem" href>Statistics</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Box-Cox-Transformations"><span>Box-Cox Transformations</span></a></li><li><a class="tocitem" href="#Time-Series-Decomposition"><span>Time Series Decomposition</span></a></li><li><a class="tocitem" href="#Autocorrelation-Functions"><span>Autocorrelation Functions</span></a></li><li><a class="tocitem" href="#Differencing"><span>Differencing</span></a></li><li><a class="tocitem" href="#Unit-Root-Tests"><span>Unit Root Tests</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Complete-Example:-Time-Series-Preprocessing-Pipeline"><span>Complete Example: Time Series Preprocessing Pipeline</span></a></li><li><a class="tocitem" href="#References-2"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../tableops/">Table Operations</a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Statistics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Statistics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/taf-society/Durbyn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/taf-society/Durbyn.jl/blob/main/docs/src/stats.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Statistics-Module"><a class="docs-heading-anchor" href="#Statistics-Module">Statistics Module</a><a id="Statistics-Module-1"></a><a class="docs-heading-anchor-permalink" href="#Statistics-Module" title="Permalink"></a></h1><p>The Stats module provides a comprehensive toolkit for time series analysis, including decomposition methods, transformation functions, autocorrelation analysis, and unit root tests. These functions are essential for preprocessing, analyzing, and understanding time series data before fitting forecasting models.</p><hr/><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The Stats module exports the following functions and types:</p><table><tr><th style="text-align: right">Category</th><th style="text-align: right">Functions/Types</th></tr><tr><td style="text-align: right"><strong>Transformations</strong></td><td style="text-align: right"><code>box_cox</code>, <code>box_cox!</code>, <code>box_cox_lambda</code>, <code>inv_box_cox</code></td></tr><tr><td style="text-align: right"><strong>Decomposition</strong></td><td style="text-align: right"><code>decompose</code>, <code>DecomposedTimeSeries</code>, <code>stl</code>, <code>STLResult</code>, <code>mstl</code>, <code>MSTLResult</code></td></tr><tr><td style="text-align: right"><strong>Differencing</strong></td><td style="text-align: right"><code>diff</code>, <code>ndiffs</code>, <code>nsdiffs</code></td></tr><tr><td style="text-align: right"><strong>Autocorrelation</strong></td><td style="text-align: right"><code>acf</code>, <code>pacf</code>, <code>ACFResult</code>, <code>PACFResult</code></td></tr><tr><td style="text-align: right"><strong>Unit Root Tests</strong></td><td style="text-align: right"><code>adf</code>, <code>ADF</code>, <code>kpss</code>, <code>KPSS</code>, <code>phillips_perron</code>, <code>PhillipsPerron</code>, <code>ocsb</code>, <code>OCSB</code></td></tr><tr><td style="text-align: right"><strong>Utilities</strong></td><td style="text-align: right"><code>fourier</code>, <code>embed</code>, <code>ols</code>, <code>OlsFit</code>, <code>approx</code>, <code>approxfun</code>, <code>seasonal_strength</code></td></tr></table><hr/><h2 id="Box-Cox-Transformations"><a class="docs-heading-anchor" href="#Box-Cox-Transformations">Box-Cox Transformations</a><a id="Box-Cox-Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Box-Cox-Transformations" title="Permalink"></a></h2><p>Box-Cox transformations stabilize variance and make data more normally distributed, which can improve forecast accuracy.</p><h3 id="Mathematical-Formulation"><a class="docs-heading-anchor" href="#Mathematical-Formulation">Mathematical Formulation</a><a id="Mathematical-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Formulation" title="Permalink"></a></h3><p>The Box-Cox transformation is defined as:</p><p class="math-container">\[y^{(\lambda)} = \begin{cases}
\frac{y^\lambda - 1}{\lambda} &amp; \text{if } \lambda \neq 0 \\
\log(y) &amp; \text{if } \lambda = 0
\end{cases}\]</p><h3 id="box_cox_lambda"><a class="docs-heading-anchor" href="#box_cox_lambda"><code>box_cox_lambda</code></a><a id="box_cox_lambda-1"></a><a class="docs-heading-anchor-permalink" href="#box_cox_lambda" title="Permalink"></a></h3><p>Automatically select the optimal Box-Cox transformation parameter.</p><pre><code class="language-julia hljs">box_cox_lambda(x, m; method=&quot;guerrero&quot;, lower=-1, upper=2)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractVector</code>: A numeric vector (must be positive for Guerrero method)</li><li><code>m::Int</code>: Frequency of the data</li><li><code>method::String</code>: Selection method - <code>&quot;guerrero&quot;</code> (default) or <code>&quot;loglik&quot;</code></li><li><code>lower::Float64</code>: Lower bound for λ search (default: -1)</li><li><code>upper::Float64</code>: Upper bound for λ search (default: 2)</li></ul><p><strong>Methods:</strong></p><ul><li><strong>Guerrero</strong>: Minimizes the coefficient of variation for subseries (Guerrero, 1993)</li><li><strong>Log-likelihood</strong>: Maximizes the profile log likelihood of a linear model</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using Durbyn.Stats

y = [120, 135, 148, 152, 141, 158, 170, 165, 180, 195]
lambda = box_cox_lambda(y, 12, method=&quot;guerrero&quot;)</code></pre><h3 id="box_cox"><a class="docs-heading-anchor" href="#box_cox"><code>box_cox</code></a><a id="box_cox-1"></a><a class="docs-heading-anchor-permalink" href="#box_cox" title="Permalink"></a></h3><p>Apply Box-Cox transformation to a series.</p><pre><code class="language-julia hljs">box_cox(x, m; lambda=&quot;auto&quot;)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractVector</code>: Input vector</li><li><code>m::Int</code>: Frequency</li><li><code>lambda</code>: Transformation parameter or <code>&quot;auto&quot;</code> for automatic selection</li></ul><p><strong>Returns:</strong> Tuple <code>(transformed_vector, lambda_used)</code></p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">y_transformed, lambda = box_cox(y, 12; lambda=&quot;auto&quot;)</code></pre><h3 id="box_cox!"><a class="docs-heading-anchor" href="#box_cox!"><code>box_cox!</code></a><a id="box_cox!-1"></a><a class="docs-heading-anchor-permalink" href="#box_cox!" title="Permalink"></a></h3><p>In-place Box-Cox transformation for memory efficiency.</p><pre><code class="language-julia hljs">box_cox!(output, x, m; lambda)</code></pre><p><strong>Note:</strong> Use this in tight loops where <code>box_cox</code> is called repeatedly to avoid allocations.</p><h3 id="inv_box_cox"><a class="docs-heading-anchor" href="#inv_box_cox"><code>inv_box_cox</code></a><a id="inv_box_cox-1"></a><a class="docs-heading-anchor-permalink" href="#inv_box_cox" title="Permalink"></a></h3><p>Reverse the Box-Cox transformation.</p><pre><code class="language-julia hljs">inv_box_cox(x; lambda, biasadj=false, fvar=nothing)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractArray</code>: Transformed data</li><li><code>lambda::Real</code>: Transformation parameter used</li><li><code>biasadj::Bool</code>: Apply bias adjustment for mean forecasts (default: false)</li><li><code>fvar</code>: Forecast variance (required if <code>biasadj=true</code>)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">y_original = inv_box_cox(y_transformed; lambda=0.5)

# With bias adjustment for forecasts
y_mean = inv_box_cox(y_transformed; lambda=0.5, biasadj=true, fvar=forecast_variance)</code></pre><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><ul><li>Box, G. E. P. and Cox, D. R. (1964). <em>An analysis of transformations</em>. JRSS B, 26, 211-246.</li><li>Guerrero, V.M. (1993). <em>Time-series analysis supported by power transformations</em>. Journal of Forecasting, 12, 37-48.</li><li>Bickel, P. J. and Doksum K. A. (1981). <em>An Analysis of Transformations Revisited</em>. JASA, 76, 296-311.</li></ul><hr/><h2 id="Time-Series-Decomposition"><a class="docs-heading-anchor" href="#Time-Series-Decomposition">Time Series Decomposition</a><a id="Time-Series-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Series-Decomposition" title="Permalink"></a></h2><h3 id="Classical-Decomposition-(decompose)"><a class="docs-heading-anchor" href="#Classical-Decomposition-(decompose)">Classical Decomposition (<code>decompose</code>)</a><a id="Classical-Decomposition-(decompose)-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-Decomposition-(decompose)" title="Permalink"></a></h3><p>Decompose a time series into trend, seasonal, and residual components using moving averages.</p><pre><code class="language-julia hljs">decompose(x; m, type=&quot;additive&quot;, filter=nothing)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractVector</code>: Time series vector</li><li><code>m::Int</code>: Frequency (observations per cycle)</li><li><code>type::String</code>: <code>&quot;additive&quot;</code> or <code>&quot;multiplicative&quot;</code></li><li><code>filter</code>: Custom filter coefficients (optional)</li></ul><p><strong>Returns:</strong> <code>DecomposedTimeSeries</code> struct with fields:</p><ul><li><code>x</code>: Original series</li><li><code>seasonal</code>: Seasonal component</li><li><code>trend</code>: Trend component</li><li><code>random</code>: Residual/remainder</li><li><code>figure</code>: Seasonal figure</li><li><code>type</code>: Decomposition type</li><li><code>m</code>: Frequency</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using Durbyn.Stats

ap = air_passengers()
result = decompose(ap; m=12, type=&quot;multiplicative&quot;)
result.trend
result.seasonal</code></pre><h3 id="STL-Decomposition-(stl)"><a class="docs-heading-anchor" href="#STL-Decomposition-(stl)">STL Decomposition (<code>stl</code>)</a><a id="STL-Decomposition-(stl)-1"></a><a class="docs-heading-anchor-permalink" href="#STL-Decomposition-(stl)" title="Permalink"></a></h3><p>Seasonal-Trend decomposition using LOESS (STL) - a robust and flexible method for decomposing time series.</p><pre><code class="language-julia hljs">stl(x, m; s_window, s_degree=0, t_window=nothing, t_degree=1,
    l_window=nothing, l_degree=t_degree, s_jump=nothing, t_jump=nothing,
    l_jump=nothing, robust=false, inner=nothing, outer=nothing)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractVector</code>: Time series to decompose</li><li><code>m::Int</code>: Seasonal frequency (must be ≥ 2)</li><li><code>s_window</code>: Seasonal smoothing window (integer or <code>&quot;periodic&quot;</code>)</li><li><code>s_degree::Int</code>: Seasonal smoothing polynomial degree (0 or 1)</li><li><code>t_window</code>: Trend smoothing window</li><li><code>t_degree::Int</code>: Trend smoothing polynomial degree (0 or 1)</li><li><code>l_window</code>: Low-pass filter window</li><li><code>l_degree::Int</code>: Low-pass filter polynomial degree</li><li><code>s_jump</code>, <code>t_jump</code>, <code>l_jump</code>: Subsampling steps</li><li><code>robust::Bool</code>: Use robustness iterations (default: false)</li><li><code>inner</code>, <code>outer</code>: Inner/outer iteration counts</li></ul><p><strong>Returns:</strong> <code>STLResult</code> struct with:</p><ul><li><code>time_series</code>: NamedTuple with <code>:seasonal</code>, <code>:trend</code>, <code>:remainder</code></li><li><code>weights</code>: Robustness weights</li><li><code>windows</code>: (s, t, l) window sizes</li><li><code>degrees</code>: (s, t, l) polynomial degrees</li><li><code>jumps</code>: (s, t, l) jump parameters</li><li><code>inner</code>, <code>outer</code>: Iteration counts</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">ap = air_passengers()
result = stl(ap, 12; s_window=7, robust=true)

# Access components
result.time_series.trend
result.time_series.seasonal
result.time_series.remainder

# Summarize and plot
summary(result)
plot(result)</code></pre><h3 id="Multiple-Seasonal-Decomposition-(mstl)"><a class="docs-heading-anchor" href="#Multiple-Seasonal-Decomposition-(mstl)">Multiple Seasonal Decomposition (<code>mstl</code>)</a><a id="Multiple-Seasonal-Decomposition-(mstl)-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Seasonal-Decomposition-(mstl)" title="Permalink"></a></h3><p>Decompose time series with multiple seasonal periods using iterative STL.</p><pre><code class="language-julia hljs">mstl(x, m; lambda=nothing, iterate=2, s_window=nothing, stl_kwargs...)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractVector</code>: Time series</li><li><code>m</code>: Single period (Int) or vector of periods</li><li><code>lambda</code>: Box-Cox parameter (<code>nothing</code>, <code>&quot;auto&quot;</code>, or numeric)</li><li><code>iterate::Int</code>: Number of outer iterations (default: 2)</li><li><code>s_window</code>: Seasonal window(s)</li><li><code>stl_kwargs...</code>: Additional arguments passed to <code>stl</code></li></ul><p><strong>Returns:</strong> <code>MSTLResult</code> struct with:</p><ul><li><code>data</code>: Original series</li><li><code>trend</code>: Trend component</li><li><code>seasonals</code>: Vector of seasonal components</li><li><code>m</code>: Periods used</li><li><code>remainder</code>: Residual component</li><li><code>lambda</code>: Box-Cox λ used</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># Hourly data with daily and weekly patterns
y = rand(200) .+ 2sin.(2π*(1:200)/7) .+ 0.5sin.(2π*(1:200)/30)
result = mstl(y; m=[7, 30], iterate=2, s_window=[11, 23], robust=true)

# Access components
result.trend
result.seasonals[1]  # First seasonal component (period 7)
result.seasonals[2]  # Second seasonal component (period 30)
result.remainder

# Summarize
summary(result)</code></pre><h3 id="Seasonal-Strength"><a class="docs-heading-anchor" href="#Seasonal-Strength">Seasonal Strength</a><a id="Seasonal-Strength-1"></a><a class="docs-heading-anchor-permalink" href="#Seasonal-Strength" title="Permalink"></a></h3><p>Measure the strength of seasonality in an MSTL decomposition.</p><pre><code class="language-julia hljs">seasonal_strength(x; m, kwargs...)
seasonal_strength(res::MSTLResult)</code></pre><p>The seasonal strength is computed as:</p><p class="math-container">\[\text{strength} = 1 - \frac{\text{Var}(\text{remainder})}{\text{Var}(\text{remainder} + \text{seasonal})}\]</p><p>Values range from 0 (no seasonality) to 1 (strong seasonality).</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">result = mstl(y; m=[7, 30])
strength = seasonal_strength(result)</code></pre><hr/><h2 id="Autocorrelation-Functions"><a class="docs-heading-anchor" href="#Autocorrelation-Functions">Autocorrelation Functions</a><a id="Autocorrelation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Autocorrelation-Functions" title="Permalink"></a></h2><h3 id="ACF-(acf)"><a class="docs-heading-anchor" href="#ACF-(acf)">ACF (<code>acf</code>)</a><a id="ACF-(acf)-1"></a><a class="docs-heading-anchor-permalink" href="#ACF-(acf)" title="Permalink"></a></h3><p>Compute the sample autocorrelation function.</p><pre><code class="language-julia hljs">acf(y, m, nlags=nothing; demean=true)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>y::AbstractVector</code>: Input time series</li><li><code>m::Int</code>: Frequency/seasonal period</li><li><code>nlags</code>: Number of lags (default: <code>min(10*log10(n), n-1)</code>)</li><li><code>demean::Bool</code>: Subtract mean before computing (default: true)</li></ul><p><strong>Returns:</strong> <code>ACFResult</code> with:</p><ul><li><code>values</code>: ACF values at each lag (including lag 0)</li><li><code>lags</code>: Lag indices</li><li><code>n</code>: Series length</li><li><code>m</code>: Frequency</li><li><code>ci</code>: 95% confidence interval (±1.96/√n)</li></ul><p><strong>Formula:</strong></p><p class="math-container">\[\hat{\rho}(k) = \frac{\sum_{t=1}^{n-k} (y_t - \bar{y})(y_{t+k} - \bar{y})}{\sum_{t=1}^{n} (y_t - \bar{y})^2}\]</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">y = randn(100)
result = acf(y, 12)
result.values  # ACF values
result.ci      # Confidence interval

plot(result)   # Requires Plots.jl</code></pre><h3 id="PACF-(pacf)"><a class="docs-heading-anchor" href="#PACF-(pacf)">PACF (<code>pacf</code>)</a><a id="PACF-(pacf)-1"></a><a class="docs-heading-anchor-permalink" href="#PACF-(pacf)" title="Permalink"></a></h3><p>Compute the sample partial autocorrelation function using the Durbin-Levinson algorithm.</p><pre><code class="language-julia hljs">pacf(y, m, nlags=nothing)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>y::AbstractVector</code>: Input time series</li><li><code>m::Int</code>: Frequency/seasonal period</li><li><code>nlags</code>: Number of lags (default: <code>min(10*log10(n), n-1)</code>)</li></ul><p><strong>Returns:</strong> <code>PACFResult</code> with:</p><ul><li><code>values</code>: PACF values (lags 1 to nlags)</li><li><code>lags</code>: Lag indices</li><li><code>n</code>: Series length</li><li><code>m</code>: Frequency</li><li><code>ci</code>: 95% confidence interval</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">y = randn(100)
result = pacf(y, 12)
result.values
plot(result)</code></pre><hr/><h2 id="Differencing"><a class="docs-heading-anchor" href="#Differencing">Differencing</a><a id="Differencing-1"></a><a class="docs-heading-anchor-permalink" href="#Differencing" title="Permalink"></a></h2><h3 id="diff"><a class="docs-heading-anchor" href="#diff"><code>diff</code></a><a id="diff-1"></a><a class="docs-heading-anchor-permalink" href="#diff" title="Permalink"></a></h3><p>Compute lagged differences of a vector or matrix.</p><pre><code class="language-julia hljs">diff(x; lag=1, differences=1)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x</code>: Vector or matrix</li><li><code>lag::Int</code>: Lag interval (default: 1)</li><li><code>differences::Int</code>: Number of times to apply differencing (default: 1)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">y = [1, 3, 6, 10, 15]
diff(y)                    # [2, 3, 4, 5]
diff(y; lag=2)             # [5, 7, 9]
diff(y; differences=2)     # [1, 1, 1]</code></pre><h3 id="ndiffs"><a class="docs-heading-anchor" href="#ndiffs"><code>ndiffs</code></a><a id="ndiffs-1"></a><a class="docs-heading-anchor-permalink" href="#ndiffs" title="Permalink"></a></h3><p>Determine the number of non-seasonal differences needed for stationarity.</p><pre><code class="language-julia hljs">ndiffs(x; alpha=0.05, test=:kpss, deterministic=:level, maxd=2, kwargs...)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractVector</code>: Time series</li><li><code>alpha::Float64</code>: Significance level (clamped to [0.01, 0.10])</li><li><code>test::Symbol</code>: Unit root test - <code>:kpss</code>, <code>:adf</code>, or <code>:pp</code></li><li><code>deterministic::Symbol</code>: <code>:level</code> (intercept) or <code>:trend</code> (intercept + trend)</li><li><code>maxd::Int</code>: Maximum differences to try (default: 2)</li></ul><p><strong>Test Behavior:</strong></p><ul><li><strong>KPSS</strong>: Null = stationarity. Returns smallest d where KPSS does not reject.</li><li><strong>ADF/PP</strong>: Null = unit root. Returns smallest d where test rejects unit root.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(100))  # Random walk (non-stationary)
d = ndiffs(y; test=:kpss)
println(&quot;Differences needed: $d&quot;)

# Using ADF test
d_adf = ndiffs(y; test=:adf, deterministic=:trend)</code></pre><h3 id="nsdiffs"><a class="docs-heading-anchor" href="#nsdiffs"><code>nsdiffs</code></a><a id="nsdiffs-1"></a><a class="docs-heading-anchor-permalink" href="#nsdiffs" title="Permalink"></a></h3><p>Determine the number of seasonal differences needed.</p><pre><code class="language-julia hljs">nsdiffs(x, m; alpha=0.05, test=:seas, maxD=1, kwargs...)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractVector</code>: Time series</li><li><code>m::Int</code>: Seasonal period</li><li><code>alpha::Float64</code>: Significance level</li><li><code>test::Symbol</code>: <code>:seas</code> (default) or <code>:ocsb</code></li><li><code>maxD::Int</code>: Maximum seasonal differences (default: 1)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">ap = air_passengers()
D = nsdiffs(ap, 12)
println(&quot;Seasonal differences needed: $D&quot;)</code></pre><hr/><h2 id="Unit-Root-Tests"><a class="docs-heading-anchor" href="#Unit-Root-Tests">Unit Root Tests</a><a id="Unit-Root-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Root-Tests" title="Permalink"></a></h2><h3 id="ADF-Test-(adf)"><a class="docs-heading-anchor" href="#ADF-Test-(adf)">ADF Test (<code>adf</code>)</a><a id="ADF-Test-(adf)-1"></a><a class="docs-heading-anchor-permalink" href="#ADF-Test-(adf)" title="Permalink"></a></h3><p>Augmented Dickey-Fuller test for unit roots.</p><pre><code class="language-julia hljs">adf(y; type=:none, lags=1, selectlags=:fixed)</code></pre><p><strong>Null Hypothesis:</strong> The series has a unit root (non-stationary)</p><p><strong>Arguments:</strong></p><ul><li><code>y::AbstractVector</code>: Time series</li><li><code>type::Symbol</code>: <code>:none</code>, <code>:drift</code> (intercept), or <code>:trend</code> (intercept + trend)</li><li><code>lags::Int</code>: Maximum augmentation order</li><li><code>selectlags::Symbol</code>: <code>:fixed</code>, <code>:aic</code>, or <code>:bic</code></li></ul><p><strong>Returns:</strong> <code>ADF</code> struct with:</p><ul><li><code>model</code>: Test type used</li><li><code>cval</code>: Critical values matrix</li><li><code>clevels</code>: Significance levels [0.01, 0.05, 0.10]</li><li><code>lag</code>: Selected augmentation order</li><li><code>teststat</code>: Test statistics (τ-statistics)</li><li><code>testreg</code>: Auxiliary regression results</li><li><code>res</code>: Residuals</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(100))
result = adf(y; type=:drift, lags=4, selectlags=:aic)
println(&quot;Test statistic: $(result.teststat[1])&quot;)
println(&quot;Critical values: $(result.cval)&quot;)</code></pre><h3 id="KPSS-Test-(kpss)"><a class="docs-heading-anchor" href="#KPSS-Test-(kpss)">KPSS Test (<code>kpss</code>)</a><a id="KPSS-Test-(kpss)-1"></a><a class="docs-heading-anchor-permalink" href="#KPSS-Test-(kpss)" title="Permalink"></a></h3><p>Kwiatkowski-Phillips-Schmidt-Shin test for stationarity.</p><pre><code class="language-julia hljs">kpss(y; type=:mu, lags=:short, use_lag=nothing)</code></pre><p><strong>Null Hypothesis:</strong> The series is stationary</p><p><strong>Arguments:</strong></p><ul><li><code>y::AbstractVector</code>: Time series</li><li><code>type::Symbol</code>: <code>:mu</code> (constant) or <code>:tau</code> (constant + trend)</li><li><code>lags::Symbol</code>: <code>:short</code>, <code>:long</code>, or <code>:nil</code></li><li><code>use_lag</code>: Manually specify bandwidth</li></ul><p><strong>Returns:</strong> <code>KPSS</code> struct with:</p><ul><li><code>type</code>: Test type</li><li><code>lag</code>: Bandwidth used</li><li><code>teststat</code>: Test statistic</li><li><code>cval</code>, <code>clevels</code>: Critical values and levels</li><li><code>res</code>: Regression residuals</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">y = randn(100)  # Stationary
result = kpss(y; type=:mu)
println(&quot;Test statistic: $(result.teststat)&quot;)
println(&quot;Critical values: $(result.cval)&quot;)</code></pre><h3 id="Phillips-Perron-Test-(phillips_perron)"><a class="docs-heading-anchor" href="#Phillips-Perron-Test-(phillips_perron)">Phillips-Perron Test (<code>phillips_perron</code>)</a><a id="Phillips-Perron-Test-(phillips_perron)-1"></a><a class="docs-heading-anchor-permalink" href="#Phillips-Perron-Test-(phillips_perron)" title="Permalink"></a></h3><p>Phillips-Perron unit root test with non-parametric correction.</p><pre><code class="language-julia hljs">phillips_perron(x; type=:Z_alpha, model=:constant, lags=:short, use_lag=nothing)</code></pre><p><strong>Null Hypothesis:</strong> The series has a unit root</p><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractVector</code>: Time series</li><li><code>type::Symbol</code>: <code>:Z_alpha</code> or <code>:Z_tau</code></li><li><code>model::Symbol</code>: <code>:constant</code> or <code>:trend</code></li><li><code>lags::Symbol</code>: <code>:short</code> or <code>:long</code></li><li><code>use_lag</code>: Bartlett truncation lag</li></ul><p><strong>Returns:</strong> <code>PhillipsPerron</code> struct with test results.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">result = phillips_perron(y; type=:Z_tau, model=:trend)</code></pre><h3 id="OCSB-Test-(ocsb)"><a class="docs-heading-anchor" href="#OCSB-Test-(ocsb)">OCSB Test (<code>ocsb</code>)</a><a id="OCSB-Test-(ocsb)-1"></a><a class="docs-heading-anchor-permalink" href="#OCSB-Test-(ocsb)" title="Permalink"></a></h3><p>Osborn-Chui-Smith-Birchenhall test for seasonal unit roots.</p><pre><code class="language-julia hljs">ocsb(x, m; lag_method=:fixed, maxlag=0, clevels=[0.10, 0.05, 0.01])</code></pre><p><strong>Null Hypothesis:</strong> Seasonal unit root exists</p><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractVector</code>: Time series</li><li><code>m::Int</code>: Seasonal period</li><li><code>lag_method::Symbol</code>: <code>:fixed</code>, <code>:AIC</code>, <code>:BIC</code>, or <code>:AICc</code></li><li><code>maxlag::Int</code>: Maximum AR order to consider</li></ul><p><strong>Returns:</strong> <code>OCSB</code> struct with:</p><ul><li><code>teststat</code>: OCSB t-statistic</li><li><code>cval</code>, <code>clevels</code>: Critical values and levels</li><li><code>lag</code>: Selected AR order</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">ap = air_passengers()
result = ocsb(ap, 12; lag_method=:AIC)</code></pre><hr/><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><h3 id="Fourier-Terms-(fourier)"><a class="docs-heading-anchor" href="#Fourier-Terms-(fourier)">Fourier Terms (<code>fourier</code>)</a><a id="Fourier-Terms-(fourier)-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-Terms-(fourier)" title="Permalink"></a></h3><p>Generate Fourier terms for seasonal modeling in regression.</p><pre><code class="language-julia hljs">fourier(x; m, K, h=nothing)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x::AbstractVector</code>: Time series</li><li><code>m</code>: Seasonal period</li><li><code>K::Int</code>: Number of Fourier terms</li><li><code>h</code>: Forecast horizon (optional)</li></ul><p><strong>Returns:</strong> Matrix of sin/cos terms</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">y = randn(100)
F = fourier(y; m=12, K=6)
# Use F as regressors in ARIMA with external regressors</code></pre><h3 id="Time-Delay-Embedding-(embed)"><a class="docs-heading-anchor" href="#Time-Delay-Embedding-(embed)">Time-Delay Embedding (<code>embed</code>)</a><a id="Time-Delay-Embedding-(embed)-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Delay-Embedding-(embed)" title="Permalink"></a></h3><p>Create a time-delay embedding matrix (lag matrix).</p><pre><code class="language-julia hljs">embed(x, dimension=1)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x</code>: Vector or matrix</li><li><code>dimension::Int</code>: Embedding dimension</li></ul><p><strong>Returns:</strong> Matrix with lags in descending order (compatible with R&#39;s <code>embed</code>)</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">y = [1, 2, 3, 4, 5]
embed(y, 3)
# Returns:
# 3  2  1
# 4  3  2
# 5  4  3</code></pre><h3 id="Ordinary-Least-Squares-(ols)"><a class="docs-heading-anchor" href="#Ordinary-Least-Squares-(ols)">Ordinary Least Squares (<code>ols</code>)</a><a id="Ordinary-Least-Squares-(ols)-1"></a><a class="docs-heading-anchor-permalink" href="#Ordinary-Least-Squares-(ols)" title="Permalink"></a></h3><p>Fit OLS linear regression.</p><pre><code class="language-julia hljs">ols(y, X)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>y::AbstractVector</code>: Response vector</li><li><code>X::AbstractMatrix</code>: Design matrix (include intercept column if needed)</li></ul><p><strong>Returns:</strong> <code>OlsFit</code> struct with:</p><ul><li><code>coef</code>: Estimated coefficients</li><li><code>fitted</code>: Fitted values</li><li><code>residuals</code>: Residuals</li><li><code>sigma2</code>: Residual variance</li><li><code>cov</code>: Coefficient covariance matrix</li><li><code>se</code>: Standard errors</li><li><code>df_residual</code>: Residual degrees of freedom</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">n = 100
X = hcat(ones(n), randn(n))  # Intercept + predictor
y = X * [2.0, 3.0] + randn(n) * 0.5

fit = ols(y, X)
fit.coef       # Coefficients
fit.se         # Standard errors
fit.residuals  # Residuals

# Predictions
predict(fit, X_new)</code></pre><h3 id="Interpolation-(approx,-approxfun)"><a class="docs-heading-anchor" href="#Interpolation-(approx,-approxfun)">Interpolation (<code>approx</code>, <code>approxfun</code>)</a><a id="Interpolation-(approx,-approxfun)-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-(approx,-approxfun)" title="Permalink"></a></h3><p>Linear or constant interpolation of data.</p><pre><code class="language-julia hljs">approx(x, y; xout=nothing, method=:linear, n=50, yleft=nothing,
       yright=nothing, rule=(1,1), f=0.0, ties=mean, na_rm=true)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>x, y</code>: Coordinates to interpolate</li><li><code>xout</code>: Output grid points (default: n equally spaced)</li><li><code>method</code>: <code>:linear</code> or <code>:constant</code></li><li><code>n</code>: Number of interpolation points</li><li><code>yleft</code>, <code>yright</code>: Extrapolation values</li><li><code>rule</code>: <code>(1,1)</code> for missing at boundaries, <code>(2,2)</code> for boundary values</li><li><code>f</code>: For <code>:constant</code>, controls step function continuity</li><li><code>ties</code>: Function to collapse duplicate x values</li></ul><p><strong>Returns:</strong> NamedTuple <code>(x=xout_vec, y=yout_vec)</code></p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">x = [1, 2, 4, 5]
y = [2, 4, 6, 8]
result = approx(x, y; n=10)

# Create interpolation function
f = approxfun(x, y)
f(3)  # Interpolate at x=3</code></pre><hr/><h2 id="Complete-Example:-Time-Series-Preprocessing-Pipeline"><a class="docs-heading-anchor" href="#Complete-Example:-Time-Series-Preprocessing-Pipeline">Complete Example: Time Series Preprocessing Pipeline</a><a id="Complete-Example:-Time-Series-Preprocessing-Pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Example:-Time-Series-Preprocessing-Pipeline" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Durbyn
using Durbyn.Stats

# Load data
ap = air_passengers()

# 1. Check for stationarity and determine differencing
d = ndiffs(ap; test=:kpss)
D = nsdiffs(ap, 12)
println(&quot;Non-seasonal differences: $d, Seasonal differences: $D&quot;)

# 2. Apply Box-Cox transformation
y_transformed, lambda = box_cox(ap, 12; lambda=&quot;auto&quot;)
println(&quot;Box-Cox lambda: $lambda&quot;)

# 3. Decompose the series
result = stl(ap, 12; s_window=7, robust=true)
summary(result)

# 4. Examine autocorrelation structure
acf_result = acf(ap, 12, 24)
pacf_result = pacf(ap, 12, 24)

# 5. Multiple seasonal decomposition (if applicable)
mstl_result = mstl(ap; m=12, lambda=lambda)
strength = seasonal_strength(mstl_result)
println(&quot;Seasonal strength: $strength&quot;)

# 6. Perform unit root tests
adf_result = adf(ap; type=:drift, selectlags=:aic)
kpss_result = kpss(ap; type=:mu)

println(&quot;ADF test statistic: $(adf_result.teststat[1])&quot;)
println(&quot;KPSS test statistic: $(kpss_result.teststat)&quot;)</code></pre><hr/><h2 id="References-2"><a class="docs-heading-anchor" href="#References-2">References</a><a class="docs-heading-anchor-permalink" href="#References-2" title="Permalink"></a></h2><ul><li>Cleveland, R. B., Cleveland, W. S., McRae, J. E., &amp; Terpenning, I. (1990). <em>STL: A Seasonal-Trend Decomposition Procedure Based on Loess</em>. Journal of Official Statistics, 6(1), 3-73.</li><li>Dickey, D. A., &amp; Fuller, W. A. (1979). <em>Distribution of the Estimators for Autoregressive Time Series with a Unit Root</em>. JASA, 74, 427-431.</li><li>Kwiatkowski, D., Phillips, P. C. B., Schmidt, P., &amp; Shin, Y. (1992). <em>Testing the Null Hypothesis of Stationarity Against the Alternative of a Unit Root</em>. Journal of Econometrics, 54, 159-178.</li><li>Phillips, P. C. B., &amp; Perron, P. (1988). <em>Testing for a Unit Root in Time Series Regression</em>. Biometrika, 72(2), 335-346.</li><li>Osborn, D. R., Chui, A. P. L., Smith, J. P., &amp; Birchenhall, C. R. (1988). <em>Seasonality and the Order of Integration for Consumption</em>. Oxford Bulletin of Economics and Statistics, 50, 361-377.</li><li>Box, G. E. P., Jenkins, G. M., Reinsel, G. C., &amp; Ljung, G. M. (2015). <em>Time Series Analysis: Forecasting and Control</em>. Wiley.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ararma/">« ARARMA</a><a class="docs-footer-nextpage" href="../optimize/">Optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 24 January 2026 20:06">Saturday 24 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
