"""
    Diffusion Model Forecasting

Functions to generate forecasts from fitted diffusion models.
"""

"""
    forecast(fit::DiffusionFit; h::Int, level::Vector{<:Real}=[80, 95]) -> Forecast

Generate forecasts from a fitted diffusion model.

# Arguments
- `fit::DiffusionFit`: A fitted diffusion model

# Keyword Arguments
- `h::Int`: Forecast horizon (number of periods to forecast)
- `level::Vector{<:Real}=[80, 95]`: Confidence levels for prediction intervals

# Returns
A `Forecast` object containing point forecasts and prediction intervals.

# Details
Point forecasts are generated by extending the diffusion curve h periods beyond
the observed (cleaned) data. When cleanlead=true was used during fitting, the
forecast time origin is adjusted to account for removed leading zeros.

Prediction intervals are computed using residual-based variance estimation
with normal approximation.

# Example
```julia
y = [5, 10, 25, 45, 70, 85, 75, 50, 30, 15]
fit = diffusion(y, model_type=Bass)
fc = forecast(fit, h=5)

fc.mean        # Point forecasts
fc.lower[1]    # 80% lower bounds
fc.upper[2]    # 95% upper bounds
```
"""
function forecast(fit::DiffusionFit; h::Int, level::Vector{<:Real}=[80, 95])
    if h < 1
        throw(ArgumentError("Forecast horizon h must be a positive integer, got $h"))
    end

    for lv in level
        if lv <= 0 || lv >= 100
            throw(ArgumentError("Confidence levels must be between 0 and 100 (exclusive), got $lv"))
        end
    end

    n = length(fit.y)

    n_extended = n + h
    curve = get_curve(fit.model_type, n_extended, fit.params)

    forecasts = curve.adoption[(n+1):n_extended]

    intervals = compute_prediction_intervals(fit, h, level)

    lower = hcat([intervals["lo_$(round(Int, lv))"] for lv in level]...)
    upper = hcat([intervals["hi_$(round(Int, lv))"] for lv in level]...)

    method = "Diffusion($(fit.model_type))"

    return Forecast(
        fit,
        method,
        forecasts,
        level,
        fit.y,
        upper,
        lower,
        fit.fitted,
        fit.residuals
    )
end

"""
    compute_prediction_intervals(fit, h, level; n_samples=1000) -> Dict

Compute prediction intervals for diffusion forecasts.

Uses residual variance estimation with normal approximation.
For adoption data, variance typically increases then decreases with the
curve shape, so we scale by the predicted mean.

# Arguments
- `fit::DiffusionFit`: Fitted model
- `h::Int`: Forecast horizon
- `level::Vector{<:Real}`: Confidence levels

# Returns
Dictionary with keys "lo_XX" and "hi_XX" for each confidence level.
"""
function compute_prediction_intervals(fit::DiffusionFit, h::Int, level::Vector{<:Real})
    T = Float64
    n = length(fit.y)

    valid_residuals = fit.residuals[isfinite.(fit.residuals)]
    if length(valid_residuals) < 2
        sigma = T(1.0)
    else
        sigma = std(valid_residuals, corrected=true)
    end

    n_extended = n + h
    curve = get_curve(fit.model_type, n_extended, fit.params)
    forecasts = curve.adoption[(n+1):n_extended]

    cv = sigma / max(mean(abs.(fit.fitted)), T(1e-10))

    intervals = Dict{String, Vector{T}}()

    for lv in level
        alpha = (100 - lv) / 100
        z = _quantile_normal(1 - alpha / 2)

        se = max.(sigma, cv .* abs.(forecasts))
        lv_key = round(Int, lv)

        intervals["lo_$lv_key"] = max.(forecasts .- z .* se, T(0.0))
        intervals["hi_$lv_key"] = forecasts .+ z .* se
    end

    return intervals
end

"""
    _quantile_normal(p) -> Float64

Compute the p-th quantile of the standard normal distribution.
Uses Abramowitz and Stegun approximation.
"""
function _quantile_normal(p::Real)
    T = Float64
    p = T(p)

    if p <= 0
        return T(-Inf)
    elseif p >= 1
        return T(Inf)
    elseif p == 0.5
        return T(0.0)
    end

    a = [
        -3.969683028665376e+01,
         2.209460984245205e+02,
        -2.759285104469687e+02,
         1.383577518672690e+02,
        -3.066479806614716e+01,
         2.506628277459239e+00
    ]
    b = [
        -5.447609879822406e+01,
         1.615858368580409e+02,
        -1.556989798598866e+02,
         6.680131188771972e+01,
        -1.328068155288572e+01
    ]
    c = [
        -7.784894002430293e-03,
        -3.223964580411365e-01,
        -2.400758277161838e+00,
        -2.549732539343734e+00,
         4.374664141464968e+00,
         2.938163982698783e+00
    ]
    d = [
         7.784695709041462e-03,
         3.224671290700398e-01,
         2.445134137142996e+00,
         3.754408661907416e+00
    ]

    p_low = T(0.02425)
    p_high = T(1.0) - p_low

    if p < p_low
        q = sqrt(-2 * log(p))
        return (((((c[1]*q + c[2])*q + c[3])*q + c[4])*q + c[5])*q + c[6]) /
               ((((d[1]*q + d[2])*q + d[3])*q + d[4])*q + 1)
    elseif p <= p_high
        q = p - T(0.5)
        r = q * q
        return (((((a[1]*r + a[2])*r + a[3])*r + a[4])*r + a[5])*r + a[6])*q /
               (((((b[1]*r + b[2])*r + b[3])*r + b[4])*r + b[5])*r + 1)
    else
        q = sqrt(-2 * log(1 - p))
        return -(((((c[1]*q + c[2])*q + c[3])*q + c[4])*q + c[5])*q + c[6]) /
                ((((d[1]*q + d[2])*q + d[3])*q + d[4])*q + 1)
    end
end

"""
    predict(fit::DiffusionFit, t::AbstractVector{<:Real}) -> NamedTuple

Predict adoption values at specific time points.

# Arguments
- `fit::DiffusionFit`: Fitted model
- `t::Vector`: Time points at which to predict

# Returns
NamedTuple with `adoption` and `cumulative` predictions.

# Example
```julia
fit = diffusion(y, model_type=Bass)
pred = predict(fit, 1:20)  # Predict for periods 1-20
```
"""
function predict(fit::DiffusionFit, t::AbstractVector{<:Real})
    for ti in t
        if !isfinite(ti) || ti != floor(ti) || ti < 1
            throw(ArgumentError("Time points must be positive integers, got $ti"))
        end
    end

    t_int = Int.(t)
    n_max = maximum(t_int)

    curve = get_curve(fit.model_type, n_max, fit.params)

    adoption = [curve.adoption[i] for i in t_int]
    cumulative = [curve.cumulative[i] for i in t_int]

    return (adoption=adoption, cumulative=cumulative)
end
