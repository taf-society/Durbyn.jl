
"""
    NamedMatrix{T}

Lightweight wrapper around a dense matrix that stores optional row names and
mandatory column names.  This type is used internally by the ARIMA fitting
machinery to keep track of exogenous regressor names.

Fields
------
`data::Matrix{T}`           The underlying numeric matrix.

`rownames::Union{Vector{String}, Nothing}`
    Optional names for rows.  If `nothing` or empty, row names will be
    autogenerated when printing.

`colnames::Vector{String}`
    Names for columns.  Must match the number of columns in `data`.
"""
struct NamedMatrix{T}
    data::Matrix{T}
    rownames::Union{Vector{String},Nothing}
    colnames::Vector{String}

    function NamedMatrix{T}(data::Matrix{T},
                            rownames::Union{Vector{String},Nothing},
                            colnames::Vector{String}) where {T}
        if !isnothing(rownames) && size(data,1) != length(rownames)
            error("Row names do not match number of rows")
        end
        if size(data,2) != length(colnames)
            error("Col names do not match number of columns")
        end
        new{T}(data, rownames, colnames)
    end
end

NamedMatrix(data::Matrix{T}, colnames::Vector{String}) where {T} =
    NamedMatrix{T}(data, nothing, colnames)

function NamedMatrix(nrows::Integer, colnames::Vector{String};
                     T::Type{<:Number}=Float64, rownames::Union{Vector{String},Nothing}=nothing)
    data = fill(NaN, nrows, length(colnames))
    NamedMatrix{T}(data, rownames, colnames)
end

"""
    select_rows(nm::NamedMatrix, rows) -> NamedMatrix

Return a new `NamedMatrix` that contains only the rows specified by `rows`
(any iterable of integer indices). Column metadata is preserved, and row
names are subset when present.
"""
function select_rows(nm::NamedMatrix, rows)
    row_inds = rows isa AbstractVector ? rows : collect(rows)
    newdata = nm.data[row_inds, :]
    newrownames = isnothing(nm.rownames) ? nothing : nm.rownames[row_inds]
    return NamedMatrix{eltype(nm.data)}(newdata, newrownames, copy(nm.colnames))
end

function setrow!(nm::NamedMatrix{T}, i::Integer, row) where {T}
    length(row) == size(nm.data, 2) || error("Row length != number of columns")
    nm.data[i, :] .= row
    return nm
end

function Base.show(io::IO, nm::NamedMatrix)
    nrow, ncol = size(nm.data)
    
    rnames = isnothing(nm.rownames) || isempty(nm.rownames) ? [string(i) for i = 1:nrow] : nm.rownames

    data_str = [string(nm.data[i, j]) for i in 1:nrow, j in 1:ncol]
    
    col_str = nm.colnames
    row_str = rnames

    colwidths = [maximum([length(col_str[j]); length.(data_str[:,j])]) for j in 1:ncol]
    rowwidth = maximum(length.(row_str))
    print(io, " " ^ (rowwidth+2))
    for j in 1:ncol
        print(io, rpad(col_str[j], colwidths[j]+2))
    end
    println(io)

    for i in 1:nrow
        print(io, rpad(row_str[i], rowwidth+2))
        for j in 1:ncol
            print(io, rpad(data_str[i, j], colwidths[j]+2))
        end
        println(io)
    end
end

function is_constant(X::NamedMatrix)
    is_constant(X.data)
end

is_constant_all(X::NamedMatrix) = is_constant_all(X.data)

function _select_columns(X::NamedMatrix, keep::AbstractVector{Bool})
    length(keep) == size(X.data, 2) ||
        throw(ArgumentError("keep mask length $(length(keep)) â‰  ncols $(size(X.data,2))"))
    newdata     = X.data[:, keep]
    newcolnames = X.colnames[keep]
    return NamedMatrix{eltype(X.data)}(newdata, X.rownames, newcolnames)
end


"""
    drop_constant_columns(X::NamedMatrix; allow_empty::Bool=false) -> Union{NamedMatrix, Nothing}

Return a new `NamedMatrix` with all constant columns removed.  
A column is considered constant if all of its values are equal.

- By default, if all columns are constant, the function returns `nothing`.
- If `allow_empty=true`, the function returns a `NamedMatrix` with
  `n` rows and zero columns instead of `nothing`.

# Examples
```julia
julia> data = [1 2 5;
               1 3 5;
               1 4 5];

julia> nm = NamedMatrix{Int}(data, ["r1","r2","r3"], ["c1","c2","c3"]);

julia> is_constant(nm)
3-element Vector{Bool}:
 true
 false
 true

julia> drop_constant_columns(nm).colnames
1-element Vector{String}:
 "c2"

julia> data2 = [1 5;
                1 5;
                1 5];

julia> nm2 = NamedMatrix{Int}(data2, ["r1","r2","r3"], ["c1","c2"]);

julia> drop_constant_columns(nm2)
nothing

julia> drop_constant_columns(nm2; allow_empty=true).data
3*0 Matrix{Int64}
"""
function drop_constant_columns(X::NamedMatrix; allow_empty::Bool=false)
     constmask = is_constant(X)
    any(constmask) || return X

    keep = .!constmask
    if !allow_empty && count(keep) == 0
        @warn "All columns are constant; nothing to keep"
        return nothing
    end
    
    return _select_columns(X, keep)
end

function is_rank_deficient(X::NamedMatrix; add_intercept::Bool=true)
    A = X.data
    M = add_intercept ? hcat(ones(size(A,1)), A) : A
    
    notnan(v) = !(v isa AbstractFloat && isnan(v))
    keep = [all(!ismissing, r) && all(notnan, r) for r in eachrow(M)]
    M = M[keep, :]
    isempty(M) && return true

    r = rank(float.(M)) 
    return r < size(M, 2)
end

function ensure_full_rank(X::NamedMatrix; add_intercept::Bool=true)
    if is_rank_deficient(X; add_intercept=add_intercept)
        throw(ArgumentError("xreg is rank deficient"))
    end
    return X
end

"""
    get_elements(
        nm::NamedMatrix;
        row::Union{Nothing, Int, AbstractVector{Int}, String, AbstractVector{String}} = nothing,
        col::Union{Nothing, Int, AbstractVector{Int}, String, AbstractVector{String}} = nothing
    )

Retrieve elements from a NamedMatrix by row and/or column **name(s)** or **index(es)**.

# Keyword Arguments

- `row`: `Nothing` (default, all rows), `Int` (single row index), `AbstractVector{Int}` (multiple row indices),
         `String` (single row name), or `AbstractVector{String}` (multiple row names).
- `col`: `Nothing` (default, all columns), `Int` (single column index), `AbstractVector{Int}` (multiple column indices),
         `String` (single column name), or `AbstractVector{String}` (multiple column names).

# Returns

A scalar, vector, or matrix, depending on the selection.

# Examples

```julia
coef = [0.1 0.2 0.3; 0.4 0.5 0.6]
rownames = ["A", "B"]
colnames = ["x", "y", "z"]
nm = NamedMatrix(coef, rownames, colnames)

get_elements(nm; row="A", col="y")
get_elements(nm; row=[1,2], col=["x","z"])
get_elements(nm; row=2)
get_elements(nm; col="z")
"""
function get_elements(
    nm::NamedMatrix;
    row::Union{Nothing, Int, AbstractVector{Int}, String, AbstractVector{String}}=nothing,
    col::Union{Nothing, Int, AbstractVector{Int}, String, AbstractVector{String}}=nothing
)
    # Row indices
    if isnothing(row)
        rowinds = 1:size(nm.data, 1)
    elseif isa(row, Int)
        rowinds = [row]
    elseif isa(row, AbstractVector{Int})
        rowinds = row
    elseif isa(row, String)
        rns = isnothing(nm.rownames) ? string.(1:size(nm.data,1)) : nm.rownames
        rowinds = [findfirst(==(row), rns)]
    elseif isa(row, AbstractVector{String})
        rns = isnothing(nm.rownames) ? string.(1:size(nm.data,1)) : nm.rownames
        rowinds = [findfirst(==(r), rns) for r in row]
    else
        error("Unsupported type for row")
    end

    # Col indices
    if isnothing(col)
        colinds = 1:size(nm.data, 2)
    elseif isa(col, Int)
        colinds = [col]
    elseif isa(col, AbstractVector{Int})
        colinds = col
    elseif isa(col, String)
        colinds = [findfirst(==(col), nm.colnames)]
    elseif isa(col, AbstractVector{String})
        colinds = [findfirst(==(c), nm.colnames) for c in col]
    else
        error("Unsupported type for col")
    end

    # Check for any not found
    if any(isnothing, rowinds) || any(isnothing, colinds)
        error("One or more row/column names not found in NamedMatrix.")
    end

    # Convert possible `Nothing`s to Ints
    rowinds = [Int(i) for i in rowinds]
    colinds = [Int(i) for i in colinds]
    return nm.data[rowinds, colinds]
end

"""
    get_vector(
        nm::NamedMatrix;
        row::Union{Nothing, Int, AbstractVector{Int}, String, AbstractVector{String}} = nothing,
        col::Union{Nothing, Int, AbstractVector{Int}, String, AbstractVector{String}} = nothing
    )

Extract a single row or column from a NamedMatrix as a 1D Julia vector.

- Exactly one of `row` or `col` must select a single row or column (by name or index).
- The other can be omitted (default, meaning all).

# Examples

```julia
coef = [0.1 0.2 0.3; 0.4 0.5 0.6]
rownames = ["A", "B"]
colnames = ["x", "y", "z"]
nm = NamedMatrix(coef, rownames, colnames)

get_vector(nm; row="A")         # => [0.1, 0.2, 0.3]
get_vector(nm; col="y")         # => [0.2, 0.5]
get_vector(nm; row=2)           # => [0.4, 0.5, 0.6]
get_vector(nm; col=3)           # => [0.3, 0.6]
"""
function get_vector(
    nm::NamedMatrix;
    row::Union{Nothing,Int,AbstractVector{Int},String,AbstractVector{String}} = nothing,
    col::Union{Nothing,Int,AbstractVector{Int},String,AbstractVector{String}} = nothing,
)
    arr = get_elements(nm; row = row, col = col)
    # Flatten row/column matrices to vector
    if size(arr, 1) == 1
        return vec(arr)   # Row as vector
    elseif size(arr, 2) == 1
        return vec(arr)   # Column as vector
    else
        error("Selection is not a single row or column; cannot convert to vector.")
    end
end

"""
    align_columns(new_data::NamedMatrix, ref_colnames::Vector{String})

Reorder the columns of `new_data` to match `ref_colnames`.  This is useful
when predicting with a fitted ARIMA model, ensuring that the exogenous
regressors in new data are aligned with the coefficients estimated during
fitting.  An error is thrown if any required column is missing from
`new_data`.
"""
function align_columns(new_data::NamedMatrix, ref_colnames::Vector{String})
    # Check for missing columns
    missing = setdiff(ref_colnames, new_data.colnames)
    !isempty(missing) && error("Missing columns in new_data: $missing")
    # Find indices in new_data.colnames for each ref_colname
    rownames = new_data.rownames
    col_indices = [findfirst(==(name), new_data.colnames) for name in ref_colnames]
    aligned_data = new_data.data[:, col_indices]
    if isnothing(rownames)
    return NamedMatrix(aligned_data, ref_colnames)
    else
    return NamedMatrix(aligned_data, new_data.rownames, ref_colnames)
    end
end

"""
    add_drift_term(nm::NamedMatrix{T}, dift::Vector{T}, dift_name::String) where {T}

Return a new `NamedMatrix` with a "dift term" column prepended to the existing data.

# Arguments
- `nm::NamedMatrix{T}`: The original `NamedMatrix`.
- `dift::Vector{T}`: The column vector to prepend.
- `dift_name::String`: Name for the new column.

# Returns
A new `NamedMatrix{T}` with `dift` as the first column and `dift_name` as its column name. All existing row names (if present) are preserved.

# Throws
- An error if the length of `dift` does not match the number of rows in `nm`.

# Example
```julia
nm = NamedMatrix([1 2; 3 4; 5 6], ["x1", "x2"])
nm2 = add_drift_term(nm, [10, 20, 30], "dift")
nm2.colnames  # ["dift", "x1", "x2"]
````
"""
function add_drift_term(nm::NamedMatrix, dift::AbstractArray, dift_name::String)
    if length(dift) != size(nm.data, 1)
        error("Dift vector length must match the number of rows in the matrix")
    end
    newdata = hcat(dift, nm.data)
    newcolnames = vcat([dift_name], nm.colnames)
    return NamedMatrix(newdata, newcolnames)
end

"""
    cbind(nm::NamedMatrix{T}, newcols::AbstractMatrix{T}, newcolnames::Vector{String}; prepend::Bool=false) where {T}

Return a new `NamedMatrix` by column-binding additional columns to the given `NamedMatrix`.

# Arguments
- `nm::NamedMatrix{T}`: The original `NamedMatrix`.
- `newcols::AbstractMatrix{T}`: Columns to be added (as a matrix; use `reshape` if needed for a single vector).
- `newcolnames::Vector{String}`: Names for the new columns.
- `prepend::Bool=false`: If `true`, new columns are added to the start; otherwise, to the end.

# Returns
A new `NamedMatrix{T}` with additional columns and updated column names.

# Throws
- An error if `newcols` does not have the same number of rows as `nm`.
- An error if `length(newcolnames)` does not match the number of columns in `newcols`.

# Example
```julia
nm = NamedMatrix([1 2; 3 4; 5 6], ["x1", "x2"])
newcols = [7; 8; 9]  # Single column (vector)
nm2 = cbind(nm, reshape(newcols, :, 1), ["x3"])
nm2.colnames  # ["x1", "x2", "x3"]
````
"""
function cbind(nm::NamedMatrix{T}, newcols::AbstractMatrix{T}, newcolnames::Vector{String}; prepend::Bool=false) where {T}
    if size(newcols, 1) != size(nm.data, 1)
        error("New columns must have the same number of rows as the NamedMatrix")
    end
    if size(newcols, 2) != length(newcolnames)
        error("Number of new column names must match number of columns in newcols")
    end
    if prepend
        combined_data = hcat(newcols, nm.data)
        combined_colnames = vcat(newcolnames, nm.colnames)
    else
        combined_data = hcat(nm.data, newcols)
        combined_colnames = vcat(nm.colnames, newcolnames)
    end
    return NamedMatrix{T}(combined_data, nm.rownames, combined_colnames)
end

