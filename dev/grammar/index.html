<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Grammar · Durbyn.jl</title><meta name="title" content="Grammar · Durbyn.jl"/><meta property="og:title" content="Grammar · Durbyn.jl"/><meta property="twitter:title" content="Grammar · Durbyn.jl"/><meta name="description" content="Documentation for Durbyn.jl."/><meta property="og:description" content="Documentation for Durbyn.jl."/><meta property="twitter:description" content="Documentation for Durbyn.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/theme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Durbyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Durbyn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><span class="tocitem">User Guide</span><ul><li class="is-active"><a class="tocitem" href>Grammar</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#ARIMA-Grammar"><span>ARIMA Grammar</span></a></li><li><a class="tocitem" href="#ETS-Grammar"><span>ETS Grammar</span></a></li><li><a class="tocitem" href="#Multi-Model-Fitting"><span>Multi-Model Fitting</span></a></li><li><a class="tocitem" href="#Complete-End-to-End-Example"><span>Complete End-to-End Example</span></a></li><li><a class="tocitem" href="#ARAR-Grammar"><span>ARAR Grammar</span></a></li><li><a class="tocitem" href="#ARARMA-Grammar"><span>ARARMA Grammar</span></a></li><li><a class="tocitem" href="#BATS-Grammar"><span>BATS Grammar</span></a></li><li><a class="tocitem" href="#Croston-Grammar"><span>Croston Grammar</span></a></li><li><a class="tocitem" href="#Tips-and-Best-Practices"><span>Tips and Best Practices</span></a></li></ul></li><li><a class="tocitem" href="../expsmoothing/">Exponential Smoothing</a></li><li><a class="tocitem" href="../theta/">Theta</a></li><li><a class="tocitem" href="../bats/">BATS</a></li><li><a class="tocitem" href="../tbats/">TBATS</a></li><li><a class="tocitem" href="../intermittent/">Intermittent Demand</a></li><li><a class="tocitem" href="../arima/">ARIMA</a></li><li><a class="tocitem" href="../arar/">ARAR</a></li><li><a class="tocitem" href="../ararma/">ARARMA</a></li><li><a class="tocitem" href="../stats/">Statistics</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../tableops/">Table Operations</a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Grammar</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Grammar</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/taf-society/Durbyn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/taf-society/Durbyn.jl/blob/main/docs/src/grammar.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Durbyn-Grammar"><a class="docs-heading-anchor" href="#Durbyn-Grammar">Durbyn Grammar</a><a id="Durbyn-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Durbyn-Grammar" title="Permalink"></a></h1><p>Durbyn provides an expressive, composable grammar for defining forecasting models. This unified interface lets you describe ARIMA, SARIMA, and exponential smoothing models with concise, readable syntax using the <code>@formula</code> macro and specialized model specifications.</p><p>Future releases will extend this grammar to support additional statistical models (state space models, structural time series, etc.) and machine learning forecasting methods, all accessible through the same consistent interface.</p><hr/><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The Durbyn grammar system consists of:</p><ul><li><strong>Formula interface</strong>: Use <code>@formula</code> to declaratively specify model components</li><li><strong>Model specifications</strong>: Wrap formulas in specs like <code>ArimaSpec</code>, <code>EtsSpec</code>, <code>SesSpec</code>, etc.</li><li><strong>Unified fitting</strong>: Call <code>fit(spec, data)</code> with optional grouping for panel data</li><li><strong>Consistent forecasting</strong>: Use <code>forecast(fitted, h)</code> for both single and grouped models; external variables can be passed if the model supports them</li></ul><p>This design eliminates manual tuning loops and provides a consistent interface across all model families.</p><hr/><h2 id="ARIMA-Grammar"><a class="docs-heading-anchor" href="#ARIMA-Grammar">ARIMA Grammar</a><a id="ARIMA-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMA-Grammar" title="Permalink"></a></h2><p>The ARIMA grammar lets you describe ARIMA and SARIMA models with flexible order specifications and exogenous variable support.</p><h3 id="Formula-Basics"><a class="docs-heading-anchor" href="#Formula-Basics">Formula Basics</a><a id="Formula-Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Formula-Basics" title="Permalink"></a></h3><p>Define the relationship between a response variable (target in ML terminology) and its ARIMA structure:</p><pre><code class="language-julia hljs">@formula(sales = p() + d() + q())</code></pre><p>Every formula requires a <strong>response variable</strong> (left-hand side; called <em>target</em> in ML) and one or more model components (right-hand side). Components may specify ARIMA orders, seasonal orders, or <strong>regressors</strong> (exogenous variables; called <em>features</em> in ML).</p><h3 id="Non-Seasonal-Orders"><a class="docs-heading-anchor" href="#Non-Seasonal-Orders">Non-Seasonal Orders</a><a id="Non-Seasonal-Orders-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Seasonal-Orders" title="Permalink"></a></h3><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Meaning</th><th style="text-align: right">Default or form</th></tr><tr><td style="text-align: right"><code>p()</code></td><td style="text-align: right">Non-seasonal AR order</td><td style="text-align: right">Search range 2–5</td></tr><tr><td style="text-align: right"><code>p(k)</code></td><td style="text-align: right">Fix AR order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>p(min,max)</code></td><td style="text-align: right">Search AR order range</td><td style="text-align: right">Searches <code>min</code> through <code>max</code></td></tr><tr><td style="text-align: right"><code>d()</code></td><td style="text-align: right">Differencing order (auto)</td><td style="text-align: right"><code>auto_arima</code> chooses</td></tr><tr><td style="text-align: right"><code>d(k)</code></td><td style="text-align: right">Fix differencing order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>q()</code></td><td style="text-align: right">Non-seasonal MA order</td><td style="text-align: right">Search range 2–5</td></tr><tr><td style="text-align: right"><code>q(k)</code></td><td style="text-align: right">Fix MA order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>q(min,max)</code></td><td style="text-align: right">Search MA order range</td><td style="text-align: right">Searches <code>min</code> through <code>max</code></td></tr></table><p>Any range <code>(min,max)</code> triggers full <code>auto_arima</code> search. If all orders are fixed, the formula interface automatically calls the faster <code>arima</code> routine.</p><h3 id="Seasonal-Orders"><a class="docs-heading-anchor" href="#Seasonal-Orders">Seasonal Orders</a><a id="Seasonal-Orders-1"></a><a class="docs-heading-anchor-permalink" href="#Seasonal-Orders" title="Permalink"></a></h3><p>Seasonal counterparts include <code>P</code>, <code>D</code>, and <code>Q</code>:</p><pre><code class="language-julia hljs">@formula(sales = p() + d() + q() + P() + Q())</code></pre><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Meaning</th><th style="text-align: right">Default or form</th></tr><tr><td style="text-align: right"><code>P()</code></td><td style="text-align: right">Seasonal AR order</td><td style="text-align: right">Search range 1–2</td></tr><tr><td style="text-align: right"><code>P(k)</code></td><td style="text-align: right">Fix seasonal AR order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>P(min,max)</code></td><td style="text-align: right">Search seasonal AR order range</td><td style="text-align: right">Searches <code>min</code> through <code>max</code></td></tr><tr><td style="text-align: right"><code>D()</code></td><td style="text-align: right">Seasonal differencing (auto)</td><td style="text-align: right"><code>auto_arima</code> chooses</td></tr><tr><td style="text-align: right"><code>D(k)</code></td><td style="text-align: right">Fix seasonal differencing order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>Q()</code></td><td style="text-align: right">Seasonal MA order</td><td style="text-align: right">Search range 1–2</td></tr><tr><td style="text-align: right"><code>Q(k)</code></td><td style="text-align: right">Fix seasonal MA order</td><td style="text-align: right">Uses <code>k</code> exactly</td></tr><tr><td style="text-align: right"><code>Q(min,max)</code></td><td style="text-align: right">Search seasonal MA order range</td><td style="text-align: right">Searches <code>min</code> through <code>max</code></td></tr></table><p>Remember to provide the seasonal period <code>m</code> when fitting: <code>fit(spec, data, m=12)</code>.</p><h3 id="Exogenous-Regressors"><a class="docs-heading-anchor" href="#Exogenous-Regressors">Exogenous Regressors</a><a id="Exogenous-Regressors-1"></a><a class="docs-heading-anchor-permalink" href="#Exogenous-Regressors" title="Permalink"></a></h3><h4 id="Explicit-Variables"><a class="docs-heading-anchor" href="#Explicit-Variables">Explicit Variables</a><a id="Explicit-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-Variables" title="Permalink"></a></h4><p>Add regressors (features) by listing column names:</p><pre><code class="language-julia hljs">@formula(sales = p() + q() + price + promotion)</code></pre><p>These become <code>VarTerm</code>s—during fitting, Durbyn pulls the matching columns from your data.</p><h4 id="Automatic-Selection-(auto())"><a class="docs-heading-anchor" href="#Automatic-Selection-(auto())">Automatic Selection (<code>auto()</code>)</a><a id="Automatic-Selection-(auto())-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Selection-(auto())" title="Permalink"></a></h4><p>Use <code>auto()</code> to include all numeric columns as regressors, excluding the response variable (target), group columns, and optional date column:</p><pre><code class="language-julia hljs">@formula(sales = auto())                    # pure auto ARIMA + automatic xregs
@formula(sales = p() + q() + auto())        # combine with explicit ARIMA orders</code></pre><p>Automatic selection is mutually exclusive with explicit exogenous variables or <code>xreg_formula</code>.</p><h4 id="Complex-Designs-(xreg_formula)"><a class="docs-heading-anchor" href="#Complex-Designs-(xreg_formula)">Complex Designs (<code>xreg_formula</code>)</a><a id="Complex-Designs-(xreg_formula)-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-Designs-(xreg_formula)" title="Permalink"></a></h4><p>For interactions or transformations, supply a secondary formula when constructing <code>ArimaSpec</code>:</p><pre><code class="language-julia hljs">spec = ArimaSpec(
    @formula(sales = p() + q()),
    xreg_formula = Formula(&quot;~ temperature * promotion + price^2&quot;)
)</code></pre><p>The <code>xreg_formula</code> is evaluated via <code>Utils.model_matrix</code>, producing the necessary design matrix before fitting.</p><h3 id="ARIMA-Examples"><a class="docs-heading-anchor" href="#ARIMA-Examples">ARIMA Examples</a><a id="ARIMA-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMA-Examples" title="Permalink"></a></h3><p><strong>Fixed orders (fast estimation)</strong>:</p><pre><code class="language-julia hljs">spec = ArimaSpec(@formula(sales = p(1) + d(1) + q(1)))
fitted = fit(spec, (sales = y,))</code></pre><p><strong>Auto ARIMA with search ranges</strong>:</p><pre><code class="language-julia hljs">spec = ArimaSpec(@formula(sales = p(0,3) + d() + q(0,3)))
fitted = fit(spec, (sales = y,))</code></pre><p><strong>Seasonal model with exogenous variables</strong>:</p><pre><code class="language-julia hljs">spec = ArimaSpec(@formula(sales = p() + d() + q() + P() + Q() + price + promotion), m = 12)
fitted = fit(spec, data; m = 12)</code></pre><p><strong>Panel data with automatic xreg</strong>:</p><pre><code class="language-julia hljs">spec = ArimaSpec(@formula(value = p() + d() + q() + P() + Q() + auto()))
panel = PanelData(tbl; groupby = :store, date = :date, m = 12)
fitted = fit(spec, panel)
fc = forecast(fitted, h = 12)</code></pre><hr/><h2 id="ETS-Grammar"><a class="docs-heading-anchor" href="#ETS-Grammar">ETS Grammar</a><a id="ETS-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#ETS-Grammar" title="Permalink"></a></h2><p>The ETS grammar mirrors the ARIMA DSL, letting you describe exponential smoothing models with expressive, composable terms.</p><h3 id="Formula-Basics-2"><a class="docs-heading-anchor" href="#Formula-Basics-2">Formula Basics</a><a class="docs-heading-anchor-permalink" href="#Formula-Basics-2" title="Permalink"></a></h3><p>Use <code>@formula</code> to define the response variable (target) and its ETS components:</p><pre><code class="language-julia hljs">@formula(sales = e(&quot;A&quot;) + t(&quot;N&quot;) + s(&quot;N&quot;))</code></pre><p>Each term is created with helper functions (<code>e</code>, <code>t</code>, <code>s</code>, <code>drift</code>). The resulting formula feeds into <code>EtsSpec</code>.</p><h3 id="Component-Functions"><a class="docs-heading-anchor" href="#Component-Functions">Component Functions</a><a id="Component-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Component-Functions" title="Permalink"></a></h3><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Meaning</th><th style="text-align: right">Accepted Codes</th></tr><tr><td style="text-align: right"><code>e()</code></td><td style="text-align: right">Error component</td><td style="text-align: right"><code>&quot;A&quot;</code> additive, <code>&quot;M&quot;</code> multiplicative, <code>&quot;Z&quot;</code> auto</td></tr><tr><td style="text-align: right"><code>t()</code></td><td style="text-align: right">Trend component</td><td style="text-align: right"><code>&quot;N&quot;</code> none, <code>&quot;A&quot;</code> additive, <code>&quot;M&quot;</code> multiplicative, <code>&quot;Z&quot;</code> auto</td></tr><tr><td style="text-align: right"><code>s()</code></td><td style="text-align: right">Seasonal component</td><td style="text-align: right"><code>&quot;N&quot;</code> none, <code>&quot;A&quot;</code> additive, <code>&quot;M&quot;</code> multiplicative, <code>&quot;Z&quot;</code> auto</td></tr></table><p>Examples:</p><pre><code class="language-julia hljs">e(&quot;A&quot;)              # Additive errors
t(&quot;M&quot;)              # Multiplicative trend
s(&quot;Z&quot;)              # Auto-select seasonal type</code></pre><p>Any component you omit defaults to <code>&quot;Z&quot;</code> (automatic selection). Combine the components as needed for your model structure.</p><h3 id="Damping-and-Drift"><a class="docs-heading-anchor" href="#Damping-and-Drift">Damping and Drift</a><a id="Damping-and-Drift-1"></a><a class="docs-heading-anchor-permalink" href="#Damping-and-Drift" title="Permalink"></a></h3><p>Use <code>drift()</code> to control trend damping:</p><table><tr><th style="text-align: right">Call</th><th style="text-align: right">Effect</th></tr><tr><td style="text-align: right"><code>drift()</code></td><td style="text-align: right">Force a damped trend (<code>damped = true</code>)</td></tr><tr><td style="text-align: right"><code>drift(false)</code></td><td style="text-align: right">Forbid damping (<code>damped = false</code>)</td></tr><tr><td style="text-align: right"><code>drift(:auto)</code></td><td style="text-align: right">Let ETS decide (<code>damped = nothing</code>)</td></tr><tr><td style="text-align: right"><code>drift(&quot;auto&quot;)</code></td><td style="text-align: right">Same as <code>drift(:auto)</code></td></tr></table><p>You can combine <code>drift</code> with any trend choice. When omitted, the ETS search decides whether to include damping.</p><h3 id="Creating-EtsSpec"><a class="docs-heading-anchor" href="#Creating-EtsSpec">Creating <code>EtsSpec</code></a><a id="Creating-EtsSpec-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-EtsSpec" title="Permalink"></a></h3><p>Construct the specification with your formula and optional keywords (passed through to <code>ets</code>):</p><pre><code class="language-julia hljs">spec = EtsSpec(
    @formula(sales = e(&quot;Z&quot;) + t(&quot;A&quot;) + s(&quot;A&quot;) + drift()),
    m = 12,           # seasonal period
    ic = &quot;aicc&quot;       # information criterion for model selection
)

fitted = fit(spec, (sales = sales_vec,); m = 12)
fc = forecast(fitted, h = 12)</code></pre><p>You can override spec options at fit time—keywords supplied to <code>fit</code> take precedence over those stored in the specification.</p><h3 id="ETS-Quick-Recipes"><a class="docs-heading-anchor" href="#ETS-Quick-Recipes">ETS Quick Recipes</a><a id="ETS-Quick-Recipes-1"></a><a class="docs-heading-anchor-permalink" href="#ETS-Quick-Recipes" title="Permalink"></a></h3><p><strong>Simple Exponential Smoothing (SES)</strong>:</p><pre><code class="language-julia hljs">spec = EtsSpec(@formula(value = e(&quot;A&quot;) + t(&quot;N&quot;) + s(&quot;N&quot;)))
fitted = fit(spec, (value = y,))</code></pre><p><strong>Holt&#39;s Linear Trend</strong>:</p><pre><code class="language-julia hljs">spec = EtsSpec(@formula(value = e(&quot;A&quot;) + t(&quot;A&quot;) + s(&quot;N&quot;) + drift(false)))
fitted = fit(spec, (value = y,))</code></pre><p><strong>Holt-Winters (Additive), monthly seasonality</strong>:</p><pre><code class="language-julia hljs">spec = EtsSpec(@formula(value = e(&quot;A&quot;) + t(&quot;A&quot;) + s(&quot;A&quot;) + drift(:auto)), m = 12)
fitted = fit(spec, (value = y,), m = 12)</code></pre><p><strong>Auto ETS with grouped data</strong>:</p><pre><code class="language-julia hljs">spec = EtsSpec(@formula(value = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;Z&quot;)))
fitted = fit(spec, table; groupby = :store, m = 12)
fc = forecast(fitted, h = 8)</code></pre><h3 id="Specialized-ETS-Shortcuts"><a class="docs-heading-anchor" href="#Specialized-ETS-Shortcuts">Specialized ETS Shortcuts</a><a id="Specialized-ETS-Shortcuts-1"></a><a class="docs-heading-anchor-permalink" href="#Specialized-ETS-Shortcuts" title="Permalink"></a></h3><p>You can also target specialized exponential smoothing families directly:</p><pre><code class="language-julia hljs"># Simple Exponential Smoothing
ses_spec = SesSpec(@formula(value = ses()))

# Holt&#39;s linear trend (damped trend forced on)
holt_spec = HoltSpec(@formula(value = holt(damped=true)))

# Holt-Winters with multiplicative seasonality
hw_spec = HoltWintersSpec(@formula(value = hw(seasonal=&quot;multiplicative&quot;)), m = 12)

# Croston&#39;s intermittent-demand method
croston_spec = CrostonSpec(@formula(demand = croston()))</code></pre><p>These specs share the same grouped/PanelData support as <code>EtsSpec</code>, and all options passed via the specification or <code>fit</code> keywords are forwarded to the underlying implementations.</p><hr/><h2 id="Multi-Model-Fitting"><a class="docs-heading-anchor" href="#Multi-Model-Fitting">Multi-Model Fitting</a><a id="Multi-Model-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Model-Fitting" title="Permalink"></a></h2><p>Use <code>ModelCollection</code> to fit multiple specifications simultaneously:</p><pre><code class="language-julia hljs">using Durbyn
using Durbyn.ModelSpecs
using Durbyn.Grammar

# Long table with :series / :date / :value columns
panel = PanelData(tbl; groupby = :series, date = :date, m = 12)

models = model(
    ArimaSpec(@formula(value = p() + q())),
    BatsSpec(@formula(value = bats(seasonal_periods=12))),
    EtsSpec(@formula(value = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;Z&quot;) + drift(:auto))),
    SesSpec(@formula(value = ses())),
    HoltSpec(@formula(value = holt(damped=true))),
    HoltWintersSpec(@formula(value = hw(seasonal=&quot;multiplicative&quot;)); m = 12),
    CrostonSpec(@formula(value = croston())),
    names = [&quot;arima&quot;, &quot;bats&quot;, &quot;ets_auto&quot;, &quot;ses&quot;, &quot;holt_damped&quot;, &quot;hw_mul&quot;, &quot;croston&quot;]
)

fitted = fit(models, panel)       # each spec fitted to every series
fc     = forecast(fitted, h = 12) # ForecastModelCollection

as_table(fc)                # stacked tidy table with model_name column</code></pre><p><code>as_table</code> stacks every model (and group) with a <code>model_name</code> column, so downstream comparisons stay tidy. You can filter to a specific model or pivot wider using <code>Durbyn.TableOps</code> functions, or use other Julia packages like <code>DataFrames.jl</code>, <code>DataFramesMeta.jl</code>, or <code>Query.jl</code>.</p><hr/><h2 id="Complete-End-to-End-Example"><a class="docs-heading-anchor" href="#Complete-End-to-End-Example">Complete End-to-End Example</a><a id="Complete-End-to-End-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-End-to-End-Example" title="Permalink"></a></h2><p>Here&#39;s a comprehensive workflow demonstrating model comparison, forecasting, and accuracy evaluation with panel data:</p><div class="admonition is-info" id="Optional-Dependencies-5cfd31aa937c2f16"><header class="admonition-header">Optional Dependencies<a class="admonition-anchor" href="#Optional-Dependencies-5cfd31aa937c2f16" title="Permalink"></a></header><div class="admonition-body"><p>This example requires <code>CSV</code> and <code>Downloads</code> packages:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add([&quot;CSV&quot;, &quot;Downloads&quot;])</code></pre></div></div><pre><code class="language-julia hljs">using Durbyn, Durbyn.TableOps, Durbyn.Grammar
using CSV, Downloads, Tables

# 1. Load and prepare data
path = Downloads.download(&quot;https://raw.githubusercontent.com/Akai01/example-time-series-datasets/refs/heads/main/Data/retail.csv&quot;)
wide = Tables.columntable(CSV.File(path))

# Reshape to long format
tbl = pivot_longer(wide; id_cols=:date, names_to=:series, values_to=:value)
glimpse(tbl)

# 2. Split into train and test sets
all_dates = unique(tbl.date)
split_date = all_dates[end-11]  # Hold out last 12 periods for testing

train = query(tbl, row -&gt; row.date &lt;= split_date)
test = query(tbl, row -&gt; row.date &gt; split_date)

println(&quot;Training data:&quot;)
glimpse(train)
println(&quot;\nTest data:&quot;)
glimpse(test)

# 3. Create panel data wrapper
panel = PanelData(train; groupby=:series, date=:date, m=12)
glimpse(panel)

# 4. Define multiple models for comparison
models = model(
    ArarSpec(@formula(value = arar())),                                # ARAR via grammar
    BatsSpec(@formula(value = bats(seasonal_periods=12))),             # BATS with seasonality
    ArimaSpec(@formula(value = p() + q())),                              # Auto ARIMA
    EtsSpec(@formula(value = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;Z&quot;) + drift(:auto))),  # Auto ETS with drift
    SesSpec(@formula(value = ses())),                                    # Simple exponential smoothing
    HoltSpec(@formula(value = holt(damped=true))),                       # Damped Holt
    HoltWintersSpec(@formula(value = hw(seasonal=:multiplicative))),     # Holt-Winters multiplicative
    CrostonSpec(@formula(value = croston())),                            # Croston&#39;s method
    names=[&quot;arar&quot;, &quot;bats&quot;, &quot;arima&quot;, &quot;ets_auto&quot;, &quot;ses&quot;, &quot;holt_damped&quot;, &quot;hw_mul&quot;, &quot;croston&quot;]
)

# 5. Fit all models to all series
fitted = fit(models, panel)

# 6. Generate forecasts (h=12 to match test set)
fc = forecast(fitted, h=12)

# 7. Convert to tidy table format
fc_tbl = as_table(fc)
glimpse(fc_tbl)

# 8. Calculate accuracy metrics across all models and series
acc_results = accuracy(fc, test)
println(&quot;\nAccuracy by Series and Model:&quot;)
glimpse(acc_results)

# 9. Visualization
list_series(fc)  # Show available series

# Quick overview of all series for first model
plot(fc, series=:all, facet=true, n_cols=4)

# Detailed inspection with actual values from test set
plot(fc, series=&quot;series_10&quot;, actual=test)

# 10. Find best and worst performing series
# Filter accuracy results for a specific metric (e.g., MAPE)
best_series = acc_results.series[argmin(acc_results.MAPE)]
worst_series = acc_results.series[argmax(acc_results.MAPE)]

# Compare best vs worst performers
plot(fc, series=[best_series, worst_series], facet=true, actual=test)</code></pre><p><strong>Key Features Demonstrated:</strong></p><ul><li><strong>Data preparation</strong>: Download, reshape, and split data using TableOps</li><li><strong>Model comparison</strong>: Fit 8 different forecasting methods simultaneously (ARAR, BATS, ARIMA, ETS, and classical methods)</li><li><strong>Panel forecasting</strong>: Automatic iteration over multiple time series</li><li><strong>Train/test split</strong>: Proper out-of-sample evaluation</li><li><strong>Accuracy metrics</strong>: Compare model performance across series</li><li><strong>Visualization</strong>: Multiple plotting options for analysis</li><li><strong>Tidy output</strong>: Structured forecast tables ready for downstream analysis</li></ul><hr/><h2 id="ARAR-Grammar"><a class="docs-heading-anchor" href="#ARAR-Grammar">ARAR Grammar</a><a id="ARAR-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#ARAR-Grammar" title="Permalink"></a></h2><p>The ARAR grammar exposes the <code>arar()</code> term so you can configure the adaptive-reduction model with the same declarative workflow as ARIMA and ETS.</p><h3 id="Formula-term"><a class="docs-heading-anchor" href="#Formula-term">Formula term</a><a id="Formula-term-1"></a><a class="docs-heading-anchor-permalink" href="#Formula-term" title="Permalink"></a></h3><pre><code class="language-julia hljs">@formula(value = arar())                           # use defaults
@formula(value = arar(max_ar_depth=20))            # custom depth
@formula(value = arar(max_ar_depth=20, max_lag=40))</code></pre><p>Both keywords are optional; if omitted, Durbyn derives appropriate values from the series length. Validation happens at macro-expansion time so mistakes are caught immediately.</p><h3 id="Direct-formula-fitting"><a class="docs-heading-anchor" href="#Direct-formula-fitting">Direct formula fitting</a><a id="Direct-formula-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-formula-fitting" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn
using Durbyn.Ararma

data = (value = air_passengers(),)
formula = @formula(value = arar(max_lag=30))
arar_model = arar(formula, data)          # tables.jl compatible data
fc  = forecast(arar_model; h = 12)</code></pre><p>The estimator lives in the <code>Durbyn.Ararma</code> submodule, so call <code>arar(formula, data)</code> from there (either via <code>using Durbyn.Ararma</code> or <code>Durbyn.Ararma.arar(...)</code>). It works with any Tables.jl source and returns the familiar <code>ARAR</code> struct.</p><h3 id="Model-specification-(ArarSpec)"><a class="docs-heading-anchor" href="#Model-specification-(ArarSpec)">Model specification (<code>ArarSpec</code>)</a><a id="Model-specification-(ArarSpec)-1"></a><a class="docs-heading-anchor-permalink" href="#Model-specification-(ArarSpec)" title="Permalink"></a></h3><p>To leverage grouped fitting, forecasting, and model collections, wrap the formula in <code>ArarSpec</code>:</p><pre><code class="language-julia hljs">spec = ArarSpec(@formula(value = arar(max_ar_depth=15)))
fitted = fit(spec, data)
fc = forecast(fitted; h = 8)</code></pre><p>For panel data:</p><pre><code class="language-julia hljs">panel = PanelData(tbl; groupby = :region)
group_fit = fit(spec, panel)
group_fc = forecast(group_fit; h = 6)</code></pre><p>And to compare against other specs:</p><pre><code class="language-julia hljs">models = model(
    ArarSpec(@formula(value = arar())),
    ArimaSpec(@formula(value = p() + q())),
    EtsSpec(@formula(value = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;Z&quot;))),
    names = [&quot;arar&quot;, &quot;arima&quot;, &quot;ets&quot;]
)

fitted = fit(models, panel)
fc = forecast(fitted; h = 12)</code></pre><p>The ARAR grammar therefore integrates seamlessly with every Durbyn workflow—single series, grouped/panel data, and large-scale model comparisons.</p><hr/><h2 id="ARARMA-Grammar"><a class="docs-heading-anchor" href="#ARARMA-Grammar">ARARMA Grammar</a><a id="ARARMA-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#ARARMA-Grammar" title="Permalink"></a></h2><p>The ARARMA grammar extends the ARAR approach by fitting a short-memory ARMA(p,q) model after the adaptive reduction stage. Like ARIMA, it uses the <code>p()</code> and <code>q()</code> terms to specify model orders, but the distinction comes from using <code>ArarmaSpec</code> instead of <code>ArimaSpec</code>.</p><h3 id="Formula-terms"><a class="docs-heading-anchor" href="#Formula-terms">Formula terms</a><a id="Formula-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Formula-terms" title="Permalink"></a></h3><p>ARARMA reuses ARIMA&#39;s order grammar:</p><pre><code class="language-julia hljs">@formula(value = p() + q())                    # auto selection with defaults
@formula(value = p(1) + q(2))                  # fixed ARARMA(1,2)
@formula(value = p(0,3) + q(0,2))              # search ranges</code></pre><p><strong>Key differences from ARIMA:</strong></p><ul><li>ARARMA does <strong>not</strong> support <code>d()</code>, <code>D()</code>, <code>P()</code>, or <code>Q()</code> terms (differencing is handled by the ARAR stage)</li><li>ARARMA does <strong>not</strong> support exogenous regressors (no variables, no <code>auto()</code>)</li><li>ARARMA adds ARAR-specific parameters: <code>max_ar_depth</code> and <code>max_lag</code></li></ul><h3 id="Automatic-vs-Fixed-Order-Selection"><a class="docs-heading-anchor" href="#Automatic-vs-Fixed-Order-Selection">Automatic vs Fixed Order Selection</a><a id="Automatic-vs-Fixed-Order-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-vs-Fixed-Order-Selection" title="Permalink"></a></h3><p><strong>If ANY order is a range</strong> → uses <code>auto_ararma()</code>:</p><ul><li><code>p() + q()</code> → searches with defaults (p: 0-4, q: 0-2)</li><li><code>p(0,3) + q()</code> → searches p ∈ {0,1,2,3}, q with defaults</li><li><code>p(1) + q(0,2)</code> → searches q ∈ {0,1,2} with fixed p=1</li></ul><p><strong>If ALL orders are fixed</strong> → uses <code>ararma()</code> directly (faster):</p><ul><li><code>p(1) + q(2)</code> → fits ARARMA(1,2) without search</li></ul><h3 id="Direct-formula-fitting-2"><a class="docs-heading-anchor" href="#Direct-formula-fitting-2">Direct formula fitting</a><a class="docs-heading-anchor-permalink" href="#Direct-formula-fitting-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn
using Durbyn.Ararma

data = (value = air_passengers(),)

# Fixed ARARMA(1,2)
formula = @formula(value = p(1) + q(2))
ararma_model = ararma(formula, data)
fc = forecast(ararma_model; h = 12)

# Auto ARARMA with custom parameters
formula = @formula(value = p() + q())
ararma_model = ararma(formula, data, max_ar_depth=20, max_lag=30, crit=:bic)
fc = forecast(ararma_model; h = 12)</code></pre><p>The estimator lives in the <code>Durbyn.Ararma</code> submodule. It works with any Tables.jl source and returns an <code>ArarmaModel</code> struct.</p><h3 id="Model-specification-(ArarmaSpec)"><a class="docs-heading-anchor" href="#Model-specification-(ArarmaSpec)">Model specification (<code>ArarmaSpec</code>)</a><a id="Model-specification-(ArarmaSpec)-1"></a><a class="docs-heading-anchor-permalink" href="#Model-specification-(ArarmaSpec)" title="Permalink"></a></h3><p>To leverage grouped fitting, forecasting, and model collections, wrap the formula in <code>ArarmaSpec</code>:</p><pre><code class="language-julia hljs"># Fixed ARARMA(2,1)
spec = ArarmaSpec(@formula(value = p(2) + q(1)))
fitted = fit(spec, data)
fc = forecast(fitted; h = 8)

# Auto ARARMA with custom ARAR parameters
spec = ArarmaSpec(
    @formula(value = p() + q()),
    max_ar_depth = 20,
    max_lag = 30,
    crit = :bic
)
fitted = fit(spec, data)
fc = forecast(fitted; h = 12)</code></pre><p>For panel data:</p><pre><code class="language-julia hljs">panel = PanelData(tbl; groupby = :region, m = m)
spec = ArarmaSpec(@formula(value = p(1) + q(1)))
group_fit = fit(spec, panel)
group_fc = forecast(group_fit; h = 6)</code></pre><p>And to compare against other specs:</p><pre><code class="language-julia hljs">models = model(
    ArarmaSpec(@formula(value = p() + q())),
    ArarSpec(@formula(value = arar())),
    ArimaSpec(@formula(value = p() + q() + P() + Q())),
    EtsSpec(@formula(value = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;Z&quot;))),
    names = [&quot;ararma&quot;, &quot;arar&quot;, &quot;arima&quot;, &quot;ets&quot;]
)

fitted = fit(models, panel)
fc = forecast(fitted; h = 12)</code></pre><p>The ARARMA grammar therefore integrates seamlessly with every Durbyn workflow—single series, grouped/panel data, and large-scale model comparisons.</p><hr/><h2 id="BATS-Grammar"><a class="docs-heading-anchor" href="#BATS-Grammar">BATS Grammar</a><a id="BATS-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#BATS-Grammar" title="Permalink"></a></h2><p>The BATS grammar provides a declarative interface for Box-Cox transformation, ARMA errors, Trend, and Seasonal components models. BATS is designed for complex seasonal patterns with integer seasonal periods and supports automatic component selection.</p><h3 id="Formula-Terms"><a class="docs-heading-anchor" href="#Formula-Terms">Formula Terms</a><a id="Formula-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Formula-Terms" title="Permalink"></a></h3><p>The <code>bats()</code> term supports flexible seasonal and component specifications:</p><pre><code class="language-julia hljs">@formula(value = bats())                                      # use defaults (auto selection)
@formula(value = bats(seasonal_periods=12))                   # single seasonal period
@formula(value = bats(seasonal_periods=[24, 168]))            # multiple seasonal periods
@formula(value = bats(seasonal_periods=12, use_box_cox=true)) # specify Box-Cox
@formula(value = bats(
    seasonal_periods=12,
    use_box_cox=true,
    use_trend=true,
    use_damped_trend=false,
    use_arma_errors=true
))</code></pre><p><strong>Available parameters:</strong></p><ul><li><code>seasonal_periods</code>: <code>Int</code> or <code>Vector{Int}</code> for seasonal period(s)</li><li><code>use_box_cox</code>: <code>Bool</code>, <code>Vector{Bool}</code>, or <code>nothing</code> (auto selection)</li><li><code>use_trend</code>: <code>Bool</code>, <code>Vector{Bool}</code>, or <code>nothing</code> (auto selection)</li><li><code>use_damped_trend</code>: <code>Bool</code>, <code>Vector{Bool}</code>, or <code>nothing</code> (auto selection)</li><li><code>use_arma_errors</code>: <code>Bool</code> to enable ARMA error modeling (default: <code>true</code>)</li></ul><p>When component parameters are <code>nothing</code>, BATS searches over both <code>true</code> and <code>false</code> options and selects the best combination using AIC.</p><h3 id="Direct-Formula-Fitting"><a class="docs-heading-anchor" href="#Direct-Formula-Fitting">Direct Formula Fitting</a><a id="Direct-Formula-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Formula-Fitting" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Durbyn

data = (sales = randn(120) .+ 10,)

# BATS with monthly seasonality
formula = @formula(sales = bats(seasonal_periods=12))
bats_model = bats(formula, data)  # Works with Tables.jl compatible data
fc = forecast(bats_model, h = 12)

# BATS with multiple seasonal periods and Box-Cox
formula = @formula(sales = bats(
    seasonal_periods=[24, 168],
    use_box_cox=true
))
bats_model = bats(formula, data)
fc = forecast(bats_model, h = 12)</code></pre><p>The <code>bats</code> function in the <code>Durbyn.Bats</code> module directly accepts formulas, making it easy to work with Tables.jl-compatible data sources.</p><h3 id="Model-Specification-(BatsSpec)"><a class="docs-heading-anchor" href="#Model-Specification-(BatsSpec)">Model Specification (<code>BatsSpec</code>)</a><a id="Model-Specification-(BatsSpec)-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Specification-(BatsSpec)" title="Permalink"></a></h3><p>To leverage grouped fitting, forecasting, and model collections, wrap the formula in <code>BatsSpec</code>:</p><pre><code class="language-julia hljs">using Durbyn.ModelSpecs

# Basic BATS with auto selection
spec = BatsSpec(@formula(value = bats()))
fitted = fit(spec, data)
fc = forecast(fitted, h = 12)

# BATS with monthly seasonality
spec = BatsSpec(@formula(value = bats(seasonal_periods=12)))
fitted = fit(spec, data)
fc = forecast(fitted, h = 12)

# BATS with specific components
spec = BatsSpec(@formula(value = bats(
    seasonal_periods=12,
    use_box_cox=true,
    use_trend=true,
    use_damped_trend=true,
    use_arma_errors=true
)))
fitted = fit(spec, data)
fc = forecast(fitted, h = 12)

# Additional options at fit time
fitted = fit(spec, data, bc_lower=0.0, bc_upper=1.5, biasadj=true)</code></pre><h3 id="Panel-Data"><a class="docs-heading-anchor" href="#Panel-Data">Panel Data</a><a id="Panel-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Panel-Data" title="Permalink"></a></h3><p>BATS integrates with panel data for multi-series forecasting:</p><pre><code class="language-julia hljs"># Create panel data (Tables.jl compatible)
tbl = (
    date = repeat(1:120, 3),
    product = repeat([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], inner=120),
    sales = randn(360) .+ 10
)

# Fit BATS to each product
spec = BatsSpec(@formula(sales = bats(seasonal_periods=12)))
fitted = fit(spec, tbl, groupby = :product)
fc = forecast(fitted, h = 12)

# Or use PanelData wrapper
panel = PanelData(tbl; groupby = :product, date = :date, m = 12)
fitted = fit(spec, panel)
fc = forecast(fitted, h = 12)</code></pre><h3 id="Model-Comparison"><a class="docs-heading-anchor" href="#Model-Comparison">Model Comparison</a><a id="Model-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Comparison" title="Permalink"></a></h3><p>Compare BATS against other forecasting methods:</p><pre><code class="language-julia hljs">models = model(
    BatsSpec(@formula(value = bats(seasonal_periods=12))),
    ArimaSpec(@formula(value = p() + q() + P() + Q())),
    EtsSpec(@formula(value = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;Z&quot;))),
    ArarSpec(@formula(value = arar())),
    names = [&quot;bats&quot;, &quot;arima&quot;, &quot;ets&quot;, &quot;arar&quot;]
)

# Fit all models
fitted = fit(models, panel)
fc = forecast(fitted, h = 12)

# Convert to tidy table
fc_table = as_table(fc)

# Compare accuracy
acc = accuracy(fc, test_data)</code></pre><h3 id="Multiple-Seasonal-Periods"><a class="docs-heading-anchor" href="#Multiple-Seasonal-Periods">Multiple Seasonal Periods</a><a id="Multiple-Seasonal-Periods-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Seasonal-Periods" title="Permalink"></a></h3><p>BATS excels at handling multiple seasonal patterns:</p><pre><code class="language-julia hljs"># Hourly data with daily (24) and weekly (168) seasonality
spec = BatsSpec(@formula(demand = bats(seasonal_periods=[24, 168])))
fitted = fit(spec, hourly_data)
fc = forecast(fitted, h = 168)  # Forecast one week ahead

# Half-hourly data with daily (48) and weekly (336) seasonality
spec = BatsSpec(@formula(load = bats(seasonal_periods=[48, 336])))
fitted = fit(spec, half_hourly_data)
fc = forecast(fitted, h = 48)  # Forecast one day ahead</code></pre><h3 id="Use-Cases"><a class="docs-heading-anchor" href="#Use-Cases">Use Cases</a><a id="Use-Cases-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Cases" title="Permalink"></a></h3><p><strong>When to use BATS:</strong></p><ul><li>Multiple integer seasonal periods (e.g., hourly data with daily and weekly patterns)</li><li>Need variance stabilization (Box-Cox transformation)</li><li>Non-constant variance over time</li><li>Complex error structures requiring ARMA modeling</li></ul><p><strong>BATS vs TBATS:</strong></p><ul><li>Use <strong>BATS</strong> for integer seasonal periods (faster, exact representation)</li><li>Use <strong>TBATS</strong> for non-integer periods, very long seasonal cycles, or dual-calendar effects</li><li>TBATS uses Fourier representation for more efficient handling of long seasonality</li></ul><p><strong>Component Selection Tips:</strong></p><ul><li>Let <code>use_box_cox=nothing</code> (default) search over both options if variance changes</li><li>Use <code>use_arma_errors=true</code> when residuals show autocorrelation</li><li>Set <code>use_damped_trend=true</code> when trend shouldn&#39;t grow indefinitely</li><li>Specify <code>bc_lower</code> and <code>bc_upper</code> to constrain Box-Cox lambda search</li></ul><h3 id="Integration-with-Durbyn-Workflows"><a class="docs-heading-anchor" href="#Integration-with-Durbyn-Workflows">Integration with Durbyn Workflows</a><a id="Integration-with-Durbyn-Workflows-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-Durbyn-Workflows" title="Permalink"></a></h3><p>The BATS grammar integrates seamlessly with all Durbyn features:</p><pre><code class="language-julia hljs"># Single series
spec = BatsSpec(@formula(sales = bats(seasonal_periods=12)))
fitted = fit(spec, (sales = y,))
fc = forecast(fitted, h = 12)

# Grouped data with parallel processing
fitted = fit(spec, df, groupby = :store, parallel = true)

# Model collection for comparison
models = model(
    BatsSpec(@formula(sales = bats(seasonal_periods=12))),
    ArimaSpec(@formula(sales = p() + q() + P() + Q())),
    names = [&quot;bats&quot;, &quot;arima&quot;]
)
fitted = fit(models, df, groupby = :store)
fc = forecast(fitted, h = 12)
fc_tbl = as_table(fc)</code></pre><hr/><h2 id="Croston-Grammar"><a class="docs-heading-anchor" href="#Croston-Grammar">Croston Grammar</a><a id="Croston-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Croston-Grammar" title="Permalink"></a></h2><p>The Croston grammar enables declarative specification of intermittent demand forecasting models through the same unified interface as ARIMA and ETS. Croston methods are designed for time series with many zero values and sporadic non-zero demands, common in spare parts inventory and slow-moving items.</p><p><strong>What is Intermittent Demand?</strong> Intermittent demand series exhibit:</p><ul><li>Many zero values (typically &gt;50% zeros)</li><li>Sporadic, irregular non-zero demands</li><li>Unpredictable timing between demand occurrences</li></ul><p>Standard forecasting methods (ARIMA, ETS) struggle with such data because they assume continuous patterns and cannot properly model the dual nature of intermittent demand: magnitude (how much) and timing (when).</p><h3 id="Formula-Terms-2"><a class="docs-heading-anchor" href="#Formula-Terms-2">Formula Terms</a><a class="docs-heading-anchor-permalink" href="#Formula-Terms-2" title="Permalink"></a></h3><p>The <code>croston()</code> term supports multiple method variants and configuration options:</p><pre><code class="language-julia hljs"># Default: Croston method (Shenstone &amp; Hyndman 2005)
@formula(demand = croston())

# Syntetos-Boylan Approximation - RECOMMENDED (bias-corrected)
@formula(demand = croston(method=&quot;sba&quot;))

# Shale-Boylan-Johnston - Alternative bias correction
@formula(demand = croston(method=&quot;sbj&quot;))

# Classical Croston (1972) - Original method with modern optimization
@formula(demand = croston(method=&quot;classic&quot;))

# With custom optimization parameters (IntermittentDemand module)
@formula(demand = croston(
    method=&quot;sba&quot;,
    cost_metric=&quot;mar&quot;,
    number_of_params=2,
    optimize_init=true
))</code></pre><p>The <code>method</code> parameter determines which algorithm to use, while additional parameters control optimization behavior for advanced methods.</p><h3 id="Method-Variants"><a class="docs-heading-anchor" href="#Method-Variants">Method Variants</a><a id="Method-Variants-1"></a><a class="docs-heading-anchor-permalink" href="#Method-Variants" title="Permalink"></a></h3><p>Four Croston method variants are available:</p><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Description</th><th style="text-align: right">Module</th><th style="text-align: right">Best For</th><th style="text-align: right">Bias Correction</th></tr><tr><td style="text-align: right"><code>&quot;sba&quot;</code> ⭐</td><td style="text-align: right">Syntetos-Boylan Approximation</td><td style="text-align: right">IntermittentDemand</td><td style="text-align: right"><strong>Default choice</strong> - bias-corrected, best accuracy</td><td style="text-align: right"><code>1 - α/2</code></td></tr><tr><td style="text-align: right"><code>&quot;sbj&quot;</code></td><td style="text-align: right">Shale-Boylan-Johnston</td><td style="text-align: right">IntermittentDemand</td><td style="text-align: right">Alternative if SBA over-forecasts</td><td style="text-align: right"><code>1 - α/(2-α)</code></td></tr><tr><td style="text-align: right"><code>&quot;classic&quot;</code></td><td style="text-align: right">Classical Croston (1972)</td><td style="text-align: right">IntermittentDemand</td><td style="text-align: right">Original method with modern optimization</td><td style="text-align: right">None (biased)</td></tr><tr><td style="text-align: right"><code>&quot;hyndman&quot;</code></td><td style="text-align: right">Croston (Shenstone &amp; Hyndman 2005)</td><td style="text-align: right">ExponentialSmoothing</td><td style="text-align: right">Standard implementation, fixed alpha</td><td style="text-align: right">None</td></tr></table><p><strong>Why Bias Correction Matters:</strong> The classical Croston method systematically over-forecasts due to Jensen&#39;s inequality when computing the ratio of smoothed demand to smoothed intervals. Both SBA and SBJ apply correction factors to reduce this bias, with empirical studies showing significant accuracy improvements.</p><p><strong>Recommendation</strong>: Start with <code>method=&quot;sba&quot;</code> - it&#39;s the most validated and generally performs best. Only consider SBJ if SBA shows consistent over-forecasting in your validation studies.</p><h3 id="IntermittentDemand-Parameters"><a class="docs-heading-anchor" href="#IntermittentDemand-Parameters">IntermittentDemand Parameters</a><a id="IntermittentDemand-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#IntermittentDemand-Parameters" title="Permalink"></a></h3><p>When using <code>&quot;classic&quot;</code>, <code>&quot;sba&quot;</code>, or <code>&quot;sbj&quot;</code> methods, additional parameters control the optimization process (based on Kourentzes 2014 recommendations):</p><pre><code class="language-julia hljs">@formula(demand = croston(
    method = &quot;sba&quot;,                  # Method variant
    cost_metric = &quot;mar&quot;,             # Loss function: &quot;mar&quot;, &quot;msr&quot;, &quot;mae&quot;, &quot;mse&quot;
    number_of_params = 2,            # 1 or 2 smoothing parameters
    optimize_init = true,            # Optimize initial states
    init_strategy = &quot;mean&quot;,          # &quot;mean&quot; or &quot;naive&quot; initialization
    rm_missing = false               # Remove missing values
))</code></pre><p><strong>Parameter Details:</strong></p><ul><li><p><strong><code>cost_metric</code></strong> (default: <code>&quot;mar&quot;</code>): Optimization loss function</p><ul><li><code>&quot;mar&quot;</code>: Mean Absolute Rate error (recommended)</li><li><code>&quot;msr&quot;</code>: Mean Squared Rate error (recommended)</li><li><code>&quot;mae&quot;</code>: Mean Absolute Error (classical)</li><li><code>&quot;mse&quot;</code>: Mean Squared Error (classical)</li></ul></li><li><p><strong><code>number_of_params</code></strong> (default: <code>2</code>): Number of smoothing parameters</p><ul><li><code>1</code>: Single parameter for both demand size and intervals</li><li><code>2</code>: Separate parameters (recommended for better accuracy)</li></ul></li><li><p><strong><code>optimize_init</code></strong> (default: <code>true</code>): Optimize initial state values</p><ul><li><code>true</code>: Optimize starting values (recommended, especially for short series)</li><li><code>false</code>: Use heuristic initialization</li></ul></li><li><p><strong><code>init_strategy</code></strong> (default: <code>&quot;mean&quot;</code>): Initial value strategy</p><ul><li><code>&quot;mean&quot;</code>: Use mean of non-zero demands and intervals</li><li><code>&quot;naive&quot;</code>: Use first observed values</li></ul></li><li><p><strong><code>rm_missing</code></strong> (default: <code>false</code>): Handle missing values</p><ul><li><code>true</code>: Remove missing observations</li><li><code>false</code>: Keep all observations</li></ul></li></ul><p><strong>Note:</strong> These parameters only apply to <code>&quot;classic&quot;</code>, <code>&quot;sba&quot;</code>, and <code>&quot;sbj&quot;</code> methods. They are ignored for <code>method=&quot;hyndman&quot;</code>.</p><h3 id="Direct-Formula-Fitting-2"><a class="docs-heading-anchor" href="#Direct-Formula-Fitting-2">Direct Formula Fitting</a><a class="docs-heading-anchor-permalink" href="#Direct-Formula-Fitting-2" title="Permalink"></a></h3><p>For single-series analysis, you can fit directly using the formula interface:</p><pre><code class="language-julia hljs">using Durbyn

# Intermittent demand data (many zeros)
data = (demand = [6, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 3, 0],)

# Recommended: Syntetos-Boylan Approximation (bias-corrected)
spec = CrostonSpec(@formula(demand = croston(method=&quot;sba&quot;)))
fit_sba = fit(spec, data)
fc_sba = forecast(fit_sba, h = 12)
plot(fc_sba)

# Alternative: Shale-Boylan-Johnston correction
spec_sbj = CrostonSpec(@formula(demand = croston(method=&quot;sbj&quot;)))
fit_sbj = fit(spec_sbj, data)
fc_sbj = forecast(fit_sbj, h = 12)

# Classical Croston with custom optimization parameters
spec_classic = CrostonSpec(@formula(demand = croston(
    method = &quot;classic&quot;,
    cost_metric = &quot;msr&quot;,        # Mean Squared Rate
    number_of_params = 2,       # Separate smoothing parameters
    optimize_init = true        # Optimize initial values
)))
fit_classic = fit(spec_classic, data)
fc_classic = forecast(fit_classic, h = 12)

# Compare methods
println(&quot;SBA forecast:     &quot;, mean(fc_sba.mean))
println(&quot;SBJ forecast:     &quot;, mean(fc_sbj.mean))
println(&quot;Classic forecast: &quot;, mean(fc_classic.mean))</code></pre><p><strong>Implementation Details:</strong> <code>CrostonSpec</code> automatically routes to the appropriate estimator:</p><ul><li><code>method = &quot;hyndman&quot;</code> → <code>ExponentialSmoothing.croston</code> (simple baseline)</li><li><code>method = &quot;classic&quot;</code>, <code>&quot;sba&quot;</code>, <code>&quot;sbj&quot;</code> → <code>Durbyn.IntermittentDemand</code> (advanced methods with optimization)</li></ul><p>No additional modules need to be loaded beyond <code>using Durbyn</code>.</p><h3 id="Panel-Data-and-Grouped-Fitting"><a class="docs-heading-anchor" href="#Panel-Data-and-Grouped-Fitting">Panel Data and Grouped Fitting</a><a id="Panel-Data-and-Grouped-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Panel-Data-and-Grouped-Fitting" title="Permalink"></a></h3><p><code>CrostonSpec</code> integrates seamlessly with panel data for multi-product forecasting:</p><pre><code class="language-julia hljs">using Durbyn, CSV, Downloads, Tables

# Load intermittent demand data with multiple products
# Data should have columns: product_id, date, demand
panel = PanelData(tbl; groupby = :product_id, date = :date)

# Fit SBA to all products (automatically parallelized)
spec = CrostonSpec(@formula(demand = croston(method=&quot;sba&quot;)))
fitted = fit(spec, panel)

# Generate forecasts for all products
fc = forecast(fitted, h = 12)

# Convert to tidy table for analysis
fc_table = as_table(fc)
glimpse(fc_table)</code></pre><h3 id="Model-Comparison-2"><a class="docs-heading-anchor" href="#Model-Comparison-2">Model Comparison</a><a class="docs-heading-anchor-permalink" href="#Model-Comparison-2" title="Permalink"></a></h3><p>Compare Croston variants with other forecasting methods:</p><pre><code class="language-julia hljs"># Define multiple models
models = model(
    CrostonSpec(@formula(demand = croston(method=&quot;sba&quot;))),
    CrostonSpec(@formula(demand = croston(method=&quot;sbj&quot;))),
    CrostonSpec(@formula(demand = croston(method=&quot;classic&quot;))),
    SesSpec(@formula(demand = ses())),
    EtsSpec(@formula(demand = e(&quot;Z&quot;) + t(&quot;Z&quot;) + s(&quot;N&quot;))),
    names = [&quot;croston_sba&quot;, &quot;croston_sbj&quot;, &quot;croston_classic&quot;, &quot;ses&quot;, &quot;ets&quot;]
)

# Fit all models to panel data
fitted = fit(models, panel)

# Generate forecasts with all methods
fc = forecast(fitted, h = 12)

# Compare accuracy against test data
acc_results = accuracy(fc, test_data)

# Find best performing model
best_model = acc_results.model_name[argmin(acc_results.MAPE)]
println(&quot;Best model: &quot;, best_model)

# Visualize comparison
plot(fc, series = &quot;product_123&quot;, actual = test_data)</code></pre><h3 id="Use-Cases-and-Best-Practices"><a class="docs-heading-anchor" href="#Use-Cases-and-Best-Practices">Use Cases and Best Practices</a><a id="Use-Cases-and-Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Cases-and-Best-Practices" title="Permalink"></a></h3><p><strong>When to use Croston methods:</strong></p><ul><li>Time series with &gt;50% zero values</li><li>Sporadic, irregular demand patterns</li><li>Spare parts and slow-moving inventory</li><li>Specialty products with infrequent sales</li></ul><p><strong>Method selection:</strong></p><ul><li><strong><code>&quot;sba&quot;</code></strong> (Syntetos-Boylan Approximation): Best choice for most applications</li><li><strong><code>&quot;sbj&quot;</code></strong> (Shale-Boylan-Johnston): Alternative bias correction, try if SBA underperforms</li><li><strong><code>&quot;classic&quot;</code></strong>: Historical comparison or when bias correction is not needed</li><li><strong><code>&quot;hyndman&quot;</code></strong>: Quick baseline, simpler implementation</li></ul><p><strong>Parameter recommendations (Kourentzes 2014):</strong></p><ul><li>Use <code>cost_metric = &quot;mar&quot;</code> or <code>&quot;msr&quot;</code> instead of classical MSE/MAE</li><li>Enable <code>number_of_params = 2</code> for separate smoothing of size and intervals</li><li>Set <code>optimize_init = true</code> especially for short time series</li><li>Let optimization run without restrictive parameter bounds</li></ul><p><strong>Integration tips:</strong></p><ul><li>Croston works seamlessly with <code>PanelData</code> for multi-product forecasting</li><li>Combine with other methods in <code>ModelCollection</code> for comprehensive comparison</li><li>Use <code>as_table()</code> for tidy output ready for downstream analysis</li><li>The Croston grammar integrates with all Durbyn workflows—single series, grouped data, and model comparison</li></ul><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><ul><li>Croston, J. (1972). &quot;Forecasting and stock control for intermittent demands&quot;. <em>Operational Research Quarterly</em>, 23(3), 289-303.</li><li>Syntetos, A.A. and Boylan, J.E. (2005). &quot;The accuracy of intermittent demand estimates&quot;. <em>International Journal of Forecasting</em>, 21(2), 303-314.</li><li>Kourentzes, N. (2014). &quot;On Intermittent Demand Model Optimisation and Selection&quot;. <em>International Journal of Production Economics</em>, 156, 180-190.</li></ul><hr/><h2 id="Tips-and-Best-Practices"><a class="docs-heading-anchor" href="#Tips-and-Best-Practices">Tips and Best Practices</a><a id="Tips-and-Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Tips-and-Best-Practices" title="Permalink"></a></h2><h3 id="ARIMA-Tips"><a class="docs-heading-anchor" href="#ARIMA-Tips">ARIMA Tips</a><a id="ARIMA-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMA-Tips" title="Permalink"></a></h3><ul><li>Any range triggers automatic model selection</li><li>Fixed orders call fast direct estimation</li><li>Exogenous support includes explicit columns, <code>auto()</code>, or complex formulas</li><li>Combine with <code>PanelData</code> to store group/date metadata cleanly</li><li>If you omit <code>newdata</code> when forecasting, Durbyn reuses each group&#39;s most recent exogenous values</li></ul><h3 id="ETS-Tips"><a class="docs-heading-anchor" href="#ETS-Tips">ETS Tips</a><a id="ETS-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#ETS-Tips" title="Permalink"></a></h3><ul><li>Always specify <code>m</code> (seasonal period) when you expect seasonal behavior. If you omit it, ETS defaults to <code>m = 1</code></li><li>Keywords like <code>lambda</code>, <code>alpha</code>, or <code>ic</code> are forwarded directly to the underlying <code>ets</code> implementation</li><li>Grouped fits reuse the same grammar—<code>fit(spec, data; groupby = [:region])</code> returns <code>GroupedFittedModels</code></li><li>Forecast works the same way for both single and grouped models</li></ul><h3 id="General-Tips"><a class="docs-heading-anchor" href="#General-Tips">General Tips</a><a id="General-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#General-Tips" title="Permalink"></a></h3><ul><li>Use <code>PanelData</code> to encapsulate grouping, date, and seasonal period information</li><li>Specifications are reusable—define once, fit to multiple datasets</li><li>Keywords in <code>fit()</code> override those stored in the spec</li><li><code>as_table()</code> provides tidy output for downstream analysis and visualization</li><li>Combine multiple specs in a <code>ModelCollection</code> for easy model comparison</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Quick Start</a><a class="docs-footer-nextpage" href="../expsmoothing/">Exponential Smoothing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 26 January 2026 12:21">Monday 26 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
